{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/PositionRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title PositionRegistry\n * @notice On-chain ledger of all shorts with P&L tracking\n * @dev Provides transparent, auditable performance metrics\n */\ncontract PositionRegistry is Ownable {\n    // ============================================\n    // ENUMS & STRUCTS\n    // ============================================\n    \n    enum PositionStatus {\n        OPEN,\n        CLOSED_PROFIT,\n        CLOSED_LOSS,\n        CLOSED_STOP_LOSS,\n        LIQUIDATED\n    }\n    \n    struct Position {\n        uint256 id;\n        address tokenAddress;\n        string chain;\n        \n        // Entry data\n        uint256 entryPrice;\n        uint256 entryTimestamp;\n        uint256 sizeTokens;\n        uint256 sizeUSDC;\n        \n        // Exit data\n        uint256 exitPrice;\n        uint256 exitTimestamp;\n        int256 pnlUSDC;\n        \n        // Metadata\n        uint16 confidenceScore;\n        bytes32[] triggeringSignals;\n        \n        PositionStatus status;\n    }\n    \n    struct DipBuyPosition {\n        uint256 id;\n        address tokenAddress;\n        string chain;\n        \n        // Entry data\n        uint256 entryPrice;\n        uint256 entryTimestamp;\n        uint256 sizeTokens;\n        uint256 sizeUSDC;\n        \n        // Exit data\n        uint256 exitPrice;\n        uint256 exitTimestamp;\n        int256 pnlUSDC;\n        \n        // Targets\n        uint256 takeProfitPrice;\n        uint256 stopLossPrice;\n        \n        // Metadata\n        uint16 confidenceScore;\n        \n        PositionStatus status;\n    }\n    \n    struct PerformanceMetrics {\n        uint256 totalPositions;\n        uint256 closedPositions;\n        uint256 profitablePositions;\n        int256 totalPnLUSDC;\n        uint256 totalVolumeUSDC;\n        \n        // Calculated fields\n        uint16 winRatePercent; // profitablePositions / closedPositions * 10000\n        int256 averagePnL;\n        int256 largestWin;\n        int256 largestLoss;\n    }\n    \n    // ============================================\n    // STATE VARIABLES\n    // ============================================\n    \n    address public nexusVault;\n    \n    mapping(uint256 => Position) public positions;\n    uint256 public positionIdCounter;\n    \n    mapping(uint256 => DipBuyPosition) public dipBuyPositions;\n    uint256 public dipBuyIdCounter;\n    \n    PerformanceMetrics public metrics;\n    PerformanceMetrics public dipBuyMetrics;\n    \n    // Chain-specific metrics\n    mapping(string => PerformanceMetrics) public chainMetrics;\n    \n    // Signal type performance tracking\n    mapping(uint8 => PerformanceMetrics) public signalTypeMetrics;\n    \n    // ============================================\n    // EVENTS\n    // ============================================\n    \n    event PositionOpened(\n        uint256 indexed positionId,\n        address indexed token,\n        string chain,\n        uint256 sizeUSDC,\n        uint16 confidenceScore\n    );\n    \n    event PositionClosed(\n        uint256 indexed positionId,\n        uint256 exitPrice,\n        int256 pnlUSDC,\n        PositionStatus status\n    );\n    \n    event PerformanceUpdated(\n        uint16 winRate,\n        int256 totalPnL,\n        uint256 totalPositions\n    );\n    \n    event DipBuyOpened(\n        uint256 indexed positionId,\n        address indexed token,\n        string chain,\n        uint256 sizeUSDC,\n        uint256 takeProfitPrice,\n        uint256 stopLossPrice\n    );\n    \n    event DipBuyClosed(\n        uint256 indexed positionId,\n        uint256 exitPrice,\n        int256 pnlUSDC,\n        PositionStatus status\n    );\n    \n    // ============================================\n    // MODIFIERS\n    // ============================================\n    \n    modifier onlyVault() {\n        require(msg.sender == nexusVault, \"Not authorized vault\");\n        _;\n    }\n    \n    // ============================================\n    // CONSTRUCTOR\n    // ============================================\n    \n    constructor() Ownable(msg.sender) {\n        // NexusVault will be set after deployment via setNexusVault()\n    }\n    \n    // ============================================\n    // CORE FUNCTIONS\n    // ============================================\n    \n    /**\n     * @notice Record a new short position\n     */\n    function recordPosition(\n        address tokenAddress,\n        string calldata chain,\n        uint256 entryPrice,\n        uint256 sizeTokens,\n        uint256 sizeUSDC,\n        uint16 confidenceScore,\n        bytes32[] calldata triggeringSignals\n    ) \n        external \n        onlyVault \n        returns (uint256 positionId) \n    {\n        positionIdCounter++;\n        positionId = positionIdCounter;\n        \n        positions[positionId] = Position({\n            id: positionId,\n            tokenAddress: tokenAddress,\n            chain: chain,\n            entryPrice: entryPrice,\n            entryTimestamp: block.timestamp,\n            sizeTokens: sizeTokens,\n            sizeUSDC: sizeUSDC,\n            exitPrice: 0,\n            exitTimestamp: 0,\n            pnlUSDC: 0,\n            confidenceScore: confidenceScore,\n            triggeringSignals: triggeringSignals,\n            status: PositionStatus.OPEN\n        });\n        \n        // Update metrics\n        metrics.totalPositions++;\n        metrics.totalVolumeUSDC += sizeUSDC;\n        \n        chainMetrics[chain].totalPositions++;\n        chainMetrics[chain].totalVolumeUSDC += sizeUSDC;\n        \n        emit PositionOpened(\n            positionId,\n            tokenAddress,\n            chain,\n            sizeUSDC,\n            confidenceScore\n        );\n        \n        return positionId;\n    }\n    \n    /**\n     * @notice Close a position and calculate P&L\n     */\n    function closePosition(\n        uint256 positionId,\n        uint256 exitPrice,\n        PositionStatus finalStatus\n    ) \n        external \n        onlyVault \n    {\n        Position storage pos = positions[positionId];\n        require(pos.status == PositionStatus.OPEN, \"Position not open\");\n        require(\n            finalStatus != PositionStatus.OPEN,\n            \"Invalid final status\"\n        );\n        \n        pos.exitPrice = exitPrice;\n        pos.exitTimestamp = block.timestamp;\n        pos.status = finalStatus;\n        \n        // Calculate P&L\n        // Short P&L = (entryPrice - exitPrice) * sizeTokens / 1e18\n        int256 priceChange = int256(pos.entryPrice) - int256(exitPrice);\n        pos.pnlUSDC = (priceChange * int256(pos.sizeTokens)) / 1e18;\n        \n        // Update global metrics\n        updatePerformanceMetrics(pos.pnlUSDC, finalStatus);\n        \n        // Update chain-specific metrics\n        updateChainMetrics(pos.chain, pos.pnlUSDC, finalStatus);\n        \n        emit PositionClosed(positionId, exitPrice, pos.pnlUSDC, finalStatus);\n        \n        emit PerformanceUpdated(\n            metrics.winRatePercent,\n            metrics.totalPnLUSDC,\n            metrics.totalPositions\n        );\n    }\n    \n    /**\n     * @notice Record a new dip buy position\n     */\n    function recordDipBuy(\n        address tokenAddress,\n        string calldata chain,\n        uint256 entryPrice,\n        uint256 sizeTokens,\n        uint256 sizeUSDC,\n        uint256 takeProfitPrice,\n        uint256 stopLossPrice,\n        uint16 confidenceScore\n    ) \n        external \n        onlyVault \n        returns (uint256 positionId) \n    {\n        dipBuyIdCounter++;\n        positionId = dipBuyIdCounter;\n        \n        dipBuyPositions[positionId] = DipBuyPosition({\n            id: positionId,\n            tokenAddress: tokenAddress,\n            chain: chain,\n            entryPrice: entryPrice,\n            entryTimestamp: block.timestamp,\n            sizeTokens: sizeTokens,\n            sizeUSDC: sizeUSDC,\n            exitPrice: 0,\n            exitTimestamp: 0,\n            pnlUSDC: 0,\n            takeProfitPrice: takeProfitPrice,\n            stopLossPrice: stopLossPrice,\n            confidenceScore: confidenceScore,\n            status: PositionStatus.OPEN\n        });\n        \n        // Update metrics\n        dipBuyMetrics.totalPositions++;\n        dipBuyMetrics.totalVolumeUSDC += sizeUSDC;\n        \n        emit DipBuyOpened(\n            positionId,\n            tokenAddress,\n            chain,\n            sizeUSDC,\n            takeProfitPrice,\n            stopLossPrice\n        );\n        \n        return positionId;\n    }\n    \n    /**\n     * @notice Close a dip buy position\n     */\n    function closeDipBuy(\n        uint256 positionId,\n        uint256 exitPrice,\n        PositionStatus finalStatus\n    ) \n        external \n        onlyVault \n    {\n        DipBuyPosition storage pos = dipBuyPositions[positionId];\n        require(pos.status == PositionStatus.OPEN, \"Position not open\");\n        require(\n            finalStatus != PositionStatus.OPEN,\n            \"Invalid final status\"\n        );\n        \n        pos.exitPrice = exitPrice;\n        pos.exitTimestamp = block.timestamp;\n        pos.status = finalStatus;\n        \n        // Calculate P&L for dip buys (profit when exitPrice > entryPrice)\n        int256 priceChange = int256(exitPrice) - int256(pos.entryPrice);\n        pos.pnlUSDC = (priceChange * int256(pos.sizeTokens)) / 1e18;\n        \n        // Update dip buy metrics\n        updateDipBuyMetrics(pos.pnlUSDC, finalStatus);\n        \n        emit DipBuyClosed(positionId, exitPrice, pos.pnlUSDC, finalStatus);\n    }\n    \n    // ============================================\n    // INTERNAL FUNCTIONS\n    // ============================================\n    \n    function updatePerformanceMetrics(\n        int256 pnl,\n        PositionStatus status\n    ) \n        internal \n    {\n        metrics.closedPositions++;\n        metrics.totalPnLUSDC += pnl;\n        \n        if (pnl > 0) {\n            metrics.profitablePositions++;\n            if (pnl > metrics.largestWin) {\n                metrics.largestWin = pnl;\n            }\n        } else if (pnl < 0) {\n            if (pnl < metrics.largestLoss) {\n                metrics.largestLoss = pnl;\n            }\n        }\n        \n        // Recalculate win rate (in basis points: 10000 = 100%)\n        if (metrics.closedPositions > 0) {\n            metrics.winRatePercent = uint16(\n                (metrics.profitablePositions * 10000) / metrics.closedPositions\n            );\n            \n            // Recalculate average P&L\n            metrics.averagePnL = metrics.totalPnLUSDC / int256(metrics.closedPositions);\n        }\n    }\n    \n    function updateChainMetrics(\n        string memory chain,\n        int256 pnl,\n        PositionStatus status\n    ) \n        internal \n    {\n        PerformanceMetrics storage chainMetric = chainMetrics[chain];\n        \n        chainMetric.closedPositions++;\n        chainMetric.totalPnLUSDC += pnl;\n        \n        if (pnl > 0) {\n            chainMetric.profitablePositions++;\n        }\n        \n        if (chainMetric.closedPositions > 0) {\n            chainMetric.winRatePercent = uint16(\n                (chainMetric.profitablePositions * 10000) / chainMetric.closedPositions\n            );\n            chainMetric.averagePnL = chainMetric.totalPnLUSDC / int256(chainMetric.closedPositions);\n        }\n    }\n    \n    function updateDipBuyMetrics(\n        int256 pnl,\n        PositionStatus status\n    ) \n        internal \n    {\n        dipBuyMetrics.closedPositions++;\n        dipBuyMetrics.totalPnLUSDC += pnl;\n        \n        if (pnl > 0) {\n            dipBuyMetrics.profitablePositions++;\n            if (pnl > dipBuyMetrics.largestWin) {\n                dipBuyMetrics.largestWin = pnl;\n            }\n        } else if (pnl < 0) {\n            if (pnl < dipBuyMetrics.largestLoss) {\n                dipBuyMetrics.largestLoss = pnl;\n            }\n        }\n        \n        // Recalculate win rate\n        if (dipBuyMetrics.closedPositions > 0) {\n            dipBuyMetrics.winRatePercent = uint16(\n                (dipBuyMetrics.profitablePositions * 10000) / dipBuyMetrics.closedPositions\n            );\n            \n            dipBuyMetrics.averagePnL = dipBuyMetrics.totalPnLUSDC / int256(dipBuyMetrics.closedPositions);\n        }\n    }\n    \n    // ============================================\n    // VIEW FUNCTIONS\n    // ============================================\n    \n    function getPosition(uint256 positionId) \n        external \n        view \n        returns (Position memory) \n    {\n        return positions[positionId];\n    }\n    \n    function getOpenPositions() \n        external \n        view \n        returns (Position[] memory) \n    {\n        uint256 openCount = 0;\n        for (uint256 i = 1; i <= positionIdCounter; i++) {\n            if (positions[i].status == PositionStatus.OPEN) {\n                openCount++;\n            }\n        }\n        \n        Position[] memory openPositions = new Position[](openCount);\n        uint256 index = 0;\n        \n        for (uint256 i = 1; i <= positionIdCounter; i++) {\n            if (positions[i].status == PositionStatus.OPEN) {\n                openPositions[index] = positions[i];\n                index++;\n            }\n        }\n        \n        return openPositions;\n    }\n    \n    function getPositionsByChain(string calldata chain) \n        external \n        view \n        returns (Position[] memory) \n    {\n        uint256 chainCount = 0;\n        for (uint256 i = 1; i <= positionIdCounter; i++) {\n            if (keccak256(bytes(positions[i].chain)) == keccak256(bytes(chain))) {\n                chainCount++;\n            }\n        }\n        \n        Position[] memory chainPositions = new Position[](chainCount);\n        uint256 index = 0;\n        \n        for (uint256 i = 1; i <= positionIdCounter; i++) {\n            if (keccak256(bytes(positions[i].chain)) == keccak256(bytes(chain))) {\n                chainPositions[index] = positions[i];\n                index++;\n            }\n        }\n        \n        return chainPositions;\n    }\n    \n    function getTopPerformers(uint256 limit) \n        external \n        view \n        returns (Position[] memory) \n    {\n        // Simple implementation - would use sorting in production\n        uint256 resultSize = limit > positionIdCounter ? positionIdCounter : limit;\n        Position[] memory topPositions = new Position[](resultSize);\n        \n        // This is a simplified version\n        // In production, implement proper sorting by pnlUSDC\n        uint256 added = 0;\n        for (uint256 i = positionIdCounter; i >= 1 && added < limit; i--) {\n            if (positions[i].status != PositionStatus.OPEN && positions[i].pnlUSDC > 0) {\n                topPositions[added] = positions[i];\n                added++;\n            }\n        }\n        \n        return topPositions;\n    }\n    \n    function getPerformanceMetrics() \n        external \n        view \n        returns (PerformanceMetrics memory) \n    {\n        return metrics;\n    }\n    \n    function getChainPerformance(string calldata chain) \n        external \n        view \n        returns (PerformanceMetrics memory) \n    {\n        return chainMetrics[chain];\n    }\n    \n    function getDipBuyPosition(uint256 positionId) \n        external \n        view \n        returns (DipBuyPosition memory) \n    {\n        return dipBuyPositions[positionId];\n    }\n    \n    function getOpenDipBuys() \n        external \n        view \n        returns (DipBuyPosition[] memory) \n    {\n        uint256 openCount = 0;\n        for (uint256 i = 1; i <= dipBuyIdCounter; i++) {\n            if (dipBuyPositions[i].status == PositionStatus.OPEN) {\n                openCount++;\n            }\n        }\n        \n        DipBuyPosition[] memory openDipBuys = new DipBuyPosition[](openCount);\n        uint256 index = 0;\n        \n        for (uint256 i = 1; i <= dipBuyIdCounter; i++) {\n            if (dipBuyPositions[i].status == PositionStatus.OPEN) {\n                openDipBuys[index] = dipBuyPositions[i];\n                index++;\n            }\n        }\n        \n        return openDipBuys;\n    }\n    \n    function getDipBuyMetrics() \n        external \n        view \n        returns (PerformanceMetrics memory) \n    {\n        return dipBuyMetrics;\n    }\n    \n    // ============================================\n    // ADMIN FUNCTIONS\n    // ============================================\n    \n    function setNexusVault(address _nexusVault) external onlyOwner {\n        require(_nexusVault != address(0), \"Invalid vault\");\n        nexusVault = _nexusVault;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}