{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "contracts/interfaces/IGMXPositionRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IGMXPositionRouter\n * @notice Interface for GMX Position Router for opening/closing leveraged positions\n * @dev Used to execute perpetual shorts on GMX\n */\ninterface IGMXPositionRouter {\n    /**\n     * @notice Create an increase position request (open or add to position)\n     * @param _path Token path for collateral (e.g., [USDC])\n     * @param _indexToken Token to long/short (e.g., WETH, WBTC)\n     * @param _amountIn Collateral amount\n     * @param _minOut Minimum tokens out (0 for shorts)\n     * @param _sizeDelta Position size increase in USD (30 decimals)\n     * @param _isLong true for long, false for short\n     * @param _acceptablePrice Max price for longs, min price for shorts (30 decimals)\n     * @param _executionFee Fee paid to keeper (msg.value)\n     * @param _referralCode Referral code for fee sharing\n     * @param _callbackTarget Address to call after execution\n     * @return requestKey Unique identifier for this position request\n     */\n    function createIncreasePosition(\n        address[] memory _path,\n        address _indexToken,\n        uint256 _amountIn,\n        uint256 _minOut,\n        uint256 _sizeDelta,\n        bool _isLong,\n        uint256 _acceptablePrice,\n        uint256 _executionFee,\n        bytes32 _referralCode,\n        address _callbackTarget\n    ) external payable returns (bytes32 requestKey);\n\n    /**\n     * @notice Create a decrease position request (close or reduce position)\n     * @param _path Token path for receiving collateral (e.g., [USDC])\n     * @param _indexToken Token being shorted/longed\n     * @param _collateralDelta Collateral to withdraw in USD (30 decimals)\n     * @param _sizeDelta Position size to decrease in USD (30 decimals)\n     * @param _isLong true for long, false for short\n     * @param _receiver Address to receive withdrawn collateral\n     * @param _acceptablePrice Min price for longs, max price for shorts (30 decimals)\n     * @param _minOut Minimum tokens to receive\n     * @param _executionFee Fee paid to keeper (msg.value)\n     * @param _withdrawETH Whether to withdraw as ETH instead of WETH\n     * @param _callbackTarget Address to call after execution\n     * @return requestKey Unique identifier for this position request\n     */\n    function createDecreasePosition(\n        address[] memory _path,\n        address _indexToken,\n        uint256 _collateralDelta,\n        uint256 _sizeDelta,\n        bool _isLong,\n        address _receiver,\n        uint256 _acceptablePrice,\n        uint256 _minOut,\n        uint256 _executionFee,\n        bool _withdrawETH,\n        address _callbackTarget\n    ) external payable returns (bytes32 requestKey);\n\n    /**\n     * @notice Get minimum execution fee required\n     */\n    function minExecutionFee() external view returns (uint256);\n\n    /**\n     * @notice Get position request by key\n     */\n    function increasePositionRequests(bytes32 key) external view returns (\n        address account,\n        address[] memory path,\n        address indexToken,\n        uint256 amountIn,\n        uint256 minOut,\n        uint256 sizeDelta,\n        bool isLong,\n        uint256 acceptablePrice,\n        uint256 executionFee,\n        uint256 blockNumber,\n        uint256 blockTime,\n        bool hasCollateralInETH,\n        address callbackTarget\n    );\n\n    /**\n     * @notice Get decrease position request by key\n     */\n    function decreasePositionRequests(bytes32 key) external view returns (\n        address account,\n        address[] memory path,\n        address indexToken,\n        uint256 collateralDelta,\n        uint256 sizeDelta,\n        bool isLong,\n        address receiver,\n        uint256 acceptablePrice,\n        uint256 minOut,\n        uint256 executionFee,\n        uint256 blockNumber,\n        uint256 blockTime,\n        bool withdrawETH,\n        address callbackTarget\n    );\n\n    /**\n     * @notice Cancel an increase position request\n     */\n    function cancelIncreasePosition(\n        bytes32 _key,\n        address payable _executionFeeReceiver\n    ) external returns (bool);\n\n    /**\n     * @notice Cancel a decrease position request\n     */\n    function cancelDecreasePosition(\n        bytes32 _key,\n        address payable _executionFeeReceiver\n    ) external returns (bool);\n}\n"
    },
    "contracts/interfaces/IGMXPositionRouterCallbackReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IGMXPositionRouterCallbackReceiver\n * @notice Interface for receiving callbacks from GMX Position Router\n * @dev Implement this to handle position execution confirmations\n */\ninterface IGMXPositionRouterCallbackReceiver {\n    /**\n     * @notice Called by GMX Position Router after position is executed\n     * @param positionKey Unique key identifying the position request\n     * @param isExecuted true if position was successfully executed\n     * @param isIncrease true for increase position, false for decrease\n     */\n    function gmxPositionCallback(\n        bytes32 positionKey,\n        bool isExecuted,\n        bool isIncrease\n    ) external;\n}\n"
    },
    "contracts/interfaces/IGMXVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IGMXVault\n * @notice Interface for GMX Vault to query positions\n * @dev Used to read position data and validate state\n */\ninterface IGMXVault {\n    /**\n     * @notice Get position details\n     * @param _account Position owner\n     * @param _collateralToken Collateral token address\n     * @param _indexToken Token being shorted/longed\n     * @param _isLong true for long, false for short\n     * @return size Position size in USD (30 decimals)\n     * @return collateral Collateral amount in USD (30 decimals)\n     * @return averagePrice Average entry price (30 decimals)\n     * @return entryFundingRate Funding rate at entry\n     * @return reserveAmount Reserved amount\n     * @return realisedPnl Realised P&L\n     * @return hasProfit Whether position has unrealised profit\n     * @return lastIncreasedTime Last time position was increased\n     */\n    function getPosition(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        bool _isLong\n    ) external view returns (\n        uint256 size,\n        uint256 collateral,\n        uint256 averagePrice,\n        uint256 entryFundingRate,\n        uint256 reserveAmount,\n        uint256 realisedPnl,\n        bool hasProfit,\n        uint256 lastIncreasedTime\n    );\n\n    /**\n     * @notice Get position delta (unrealised P&L)\n     * @return hasProfit Whether position is profitable\n     * @return delta Absolute P&L amount\n     */\n    function getPositionDelta(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        bool _isLong\n    ) external view returns (bool hasProfit, uint256 delta);\n\n    /**\n     * @notice Get current price of token\n     */\n    function getMaxPrice(address _token) external view returns (uint256);\n    \n    /**\n     * @notice Get minimum price of token\n     */\n    function getMinPrice(address _token) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IPositionRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IPositionRegistry {\n    enum PositionStatus {\n        OPEN,\n        CLOSED_PROFIT,\n        CLOSED_LOSS,\n        CLOSED_STOP_LOSS,\n        LIQUIDATED\n    }\n    \n    function recordPosition(\n        address tokenAddress,\n        string calldata chain,\n        uint256 entryPrice,\n        uint256 sizeTokens,\n        uint256 sizeUSDC,\n        uint16 confidenceScore,\n        bytes32[] calldata triggeringSignals\n    ) external returns (uint256 positionId);\n    \n    function closePosition(\n        uint256 positionId,\n        uint256 exitPrice,\n        PositionStatus finalStatus\n    ) external;\n}\n"
    },
    "contracts/interfaces/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IPriceOracle {\n    function getPrice(\n        address tokenAddress,\n        string calldata chain\n    ) external view returns (uint256 price);\n}\n"
    },
    "contracts/interfaces/ISignalOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface ISignalOracle {\n    enum SignalType {\n        INSIDER_WALLET_DUMP,\n        LIQUIDITY_REMOVAL,\n        TWITTER_ENGAGEMENT_DROP,\n        TWITTER_SENTIMENT_NEGATIVE,\n        GOVERNANCE_BEARISH,\n        GITHUB_COMMIT_DROP,\n        DEVELOPER_EXODUS,\n        WHALE_ALERT,\n        REGULATORY_RISK,\n        MACRO_EVENT,\n        INSTITUTIONAL_MOVE,\n        SENTIMENT_SHIFT\n    }\n    \n    function getConfidenceScore(\n        address tokenAddress,\n        string calldata chain\n    ) external view returns (uint16 totalScore, uint8 signalCount);\n    \n    function getRecentSignalIds(\n        address tokenAddress,\n        string calldata chain\n    ) external view returns (bytes32[] memory);\n}\n"
    },
    "contracts/NexusVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./interfaces/ISignalOracle.sol\";\nimport \"./interfaces/IPositionRegistry.sol\";\nimport \"./interfaces/IPriceOracle.sol\";\nimport \"./interfaces/IGMXPositionRouter.sol\";\nimport \"./interfaces/IGMXVault.sol\";\nimport \"./interfaces/IGMXPositionRouterCallbackReceiver.sol\";\n\n/**\n * @title NexusVault\n * @notice Main execution contract for cross-chain autonomous shorts via LI.FI + GMX\n * @dev Holds USDC treasury, bridges via LI.FI, executes perpetual shorts on GMX\n * \n * Architecture:\n * 1. User funds on any chain → LI.FI bridges to Arbitrum\n * 2. On Arbitrum, opens GMX perpetual SHORT position\n * 3. Price crashes, GMX SHORT profits\n * 4. Close position, bridge profits back via LI.FI\n */\ncontract NexusVault is Ownable, ReentrancyGuard, IGMXPositionRouterCallbackReceiver {\n    // ============================================\n    // STATE VARIABLES\n    // ============================================\n    \n    address public immutable USDC;\n    address public agentAddress;\n    \n    ISignalOracle public signalOracle;\n    IPositionRegistry public positionRegistry;\n    IPriceOracle public priceOracle;\n    IGMXPositionRouter public gmxPositionRouter;\n    IGMXVault public gmxVault;\n    \n    bool public paused;\n    uint256 public constant MAX_POSITION_PERCENT = 20; // Max 20% of vault in one position\n    uint256 public constant MIN_CONFIDENCE_SCORE = 70; // Minimum 70/100 confidence\n    uint256 public constant DEFAULT_LEVERAGE = 2; // 2x leverage (can be 1-50x on GMX)\n    uint256 public constant GMX_PRICE_PRECISION = 1e30; // GMX uses 30 decimals for USD\n    \n    // Approved tokens for shorting (whitelist to prevent scams)\n    mapping(address => bool) public approvedTokens;\n    \n    // Chain whitelist (must be \"arbitrum\" for GMX)\n    mapping(string => bool) public approvedChains;\n    \n    // Position tracking\n    mapping(uint256 => ShortPosition) public positions;\n    uint256 public positionCounter;\n    \n    // GMX position key → NEXUS position ID\n    mapping(bytes32 => uint256) public gmxKeyToPositionId;\n    \n    // Position ID → Pending bridge back request\n    mapping(uint256 => BridgeBackRequest) public pendingBridgeBack;\n    \n    // Dip buy positions (memecoin post-rug buys)\n    mapping(uint256 => DipBuyPosition) public dipBuyPositions;\n    uint256 public dipBuyCounter;\n    \n    uint256 public constant MAX_DIP_BUY_PERCENT = 5; // Max 5% of vault on dip buys\n    \n    struct ShortPosition {\n        uint256 id;\n        address indexToken;      // Token being shorted (e.g., WETH, WBTC)\n        uint256 collateralUSDC;  // USDC collateral amount\n        uint256 positionSizeUSD; // Position size in USD (30 decimals)\n        uint256 leverage;        // Leverage multiplier\n        uint256 entryPrice;      // Entry price (30 decimals)\n        uint256 entryTimestamp;\n        bytes32 gmxPositionKey;  // GMX request key\n        bool isOpen;\n        string sourceChain;      // Original chain funds came from\n    }\n    \n    struct BridgeBackRequest {\n        string destinationChain;\n        address recipient;\n        uint256 timestamp;\n    }\n    \n    struct DipBuyPosition {\n        uint256 id;\n        address token;           // Memecoin being bought\n        string chain;            // Chain where token lives\n        uint256 entryPrice;      // Buy price (18 decimals)\n        uint256 sizeTokens;      // Amount of tokens bought\n        uint256 sizeUSDC;        // USDC spent\n        uint256 takeProfitPrice; // Target sell price (+30-50%)\n        uint256 stopLossPrice;   // Stop loss price (-15%)\n        uint256 entryTimestamp;\n        bool isOpen;\n        string sourceChain;      // Original chain funds came from\n    }\n    \n    // ============================================\n    // EVENTS\n    // ============================================\n    \n    event BridgeInitiated(\n        string indexed sourceChain,\n        uint256 amountUSDC,\n        bytes32 lifiTransferId\n    );\n    \n    event LiFiBridgeExecuted(\n        bytes32 indexed transactionId,\n        string sourceChain,\n        uint256 destinationChainId,\n        uint256 amountUSDC\n    );\n    \n    event ShortExecuted(\n        uint256 indexed positionId,\n        address indexed indexToken,\n        uint256 collateralUSDC,\n        uint256 positionSizeUSD,\n        uint256 leverage,\n        uint16 confidenceScore,\n        bytes32 gmxPositionKey\n    );\n    \n    event PositionClosed(\n        uint256 indexed positionId,\n        uint256 exitPrice,\n        int256 pnlUSDC,\n        uint256 finalUSDC\n    );\n    \n    event GMXCallbackReceived(\n        bytes32 indexed positionKey,\n        bool isExecuted,\n        bool isIncrease,\n        uint256 nexusPositionId\n    );\n    \n    event BridgeBackInitiated(\n        uint256 indexed positionId,\n        string destinationChain,\n        uint256 amountUSDC\n    );\n    \n    event DipBuyInitiated(\n        uint256 indexed positionId,\n        address indexed token,\n        string chain,\n        uint256 amountUSDC\n    );\n    \n    event DipBuyExecuted(\n        uint256 indexed positionId,\n        uint256 tokensReceived,\n        uint256 executionPrice\n    );\n    \n    event DipBuyClosed(\n        uint256 indexed positionId,\n        uint256 exitPrice,\n        int256 pnlUSDC,\n        bool isProfit\n    );\n    \n    event Deposit(address indexed user, uint256 amount);\n    event TokenApproved(address indexed token, bool approved);\n    event ChainApproved(string chain, bool approved);\n    event AgentUpdated(address indexed oldAgent, address indexed newAgent);\n    event EmergencyWithdraw(address indexed token, uint256 amount);\n    event PositionCloseRequested(uint256 indexed positionId, uint256 minExitPrice);\n    \n    // ============================================\n    // MODIFIERS\n    // ============================================\n    \n    modifier onlyAgent() {\n        require(msg.sender == agentAddress, \"Not authorized agent\");\n        _;\n    }\n    \n    modifier whenNotPaused() {\n        require(!paused, \"Vault is paused\");\n        _;\n    }\n    \n    // ============================================\n    // CONSTRUCTOR\n    // ============================================\n    \n    constructor(\n        address _usdc,\n        address _agentAddress,\n        address _signalOracle,\n        address _positionRegistry,\n        address _priceOracle,\n        address _gmxPositionRouter,\n        address _gmxVault\n    ) Ownable(msg.sender) {\n        USDC = _usdc;\n        agentAddress = _agentAddress;\n        signalOracle = ISignalOracle(_signalOracle);\n        positionRegistry = IPositionRegistry(_positionRegistry);\n        priceOracle = IPriceOracle(_priceOracle);\n        gmxPositionRouter = IGMXPositionRouter(_gmxPositionRouter);\n        gmxVault = IGMXVault(_gmxVault);\n        \n        // Only Arbitrum is approved (GMX is only on Arbitrum)\n        approvedChains[\"arbitrum\"] = true;\n    }\n    \n    // ============================================\n    // CORE FUNCTIONS\n    // ============================================\n    \n    /**\n     * @notice Deposit USDC into the vault\n     * @param amount Amount of USDC to deposit (6 decimals)\n     */\n    function deposit(uint256 amount) external whenNotPaused nonReentrant {\n        require(amount > 0, \"Amount must be > 0\");\n        IERC20(USDC).transferFrom(msg.sender, address(this), amount);\n        emit Deposit(msg.sender, amount);\n    }\n    \n    \n    /**\n     * @notice Execute a GMX short position (USDC must already be on Arbitrum)\n     * @dev Cross-chain bridging is handled off-chain by LI.FI SDK (TypeScript)\n     *      This contract only opens GMX shorts with USDC already on Arbitrum\n     * \n     * @param indexToken Token to short (e.g., WETH, WBTC)\n     * @param amountUSDC Collateral amount in USDC (6 decimals)\n     * @param leverage Leverage multiplier (1-50x, typically 2-10x)\n     * @param acceptablePrice Maximum entry price for short (30 decimals)\n     * @return positionId The ID of the created position\n     */\n    function executeShort(\n        address indexToken,\n        uint256 amountUSDC,\n        uint256 leverage,\n        uint256 acceptablePrice\n    ) \n        external \n        payable\n        onlyAgent \n        whenNotPaused \n        nonReentrant \n        returns (uint256 positionId) \n    {\n        // 1. Validate inputs\n        require(approvedTokens[indexToken], \"Token not approved\");\n        require(leverage >= 1 && leverage <= 50, \"Invalid leverage\");\n        require(msg.value >= gmxPositionRouter.minExecutionFee(), \"Insufficient execution fee\");\n        \n        // 2. Check position limits (max 20% of vault)\n        uint256 vaultBalance = IERC20(USDC).balanceOf(address(this));\n        uint256 maxPositionSize = (vaultBalance * MAX_POSITION_PERCENT) / 100;\n        require(amountUSDC <= maxPositionSize, \"Position exceeds max size\");\n        require(amountUSDC <= vaultBalance, \"Insufficient vault balance\");\n        \n        // 3. Get confidence from SignalOracle\n        (uint16 confidenceScore, uint8 signalCount) = signalOracle.getConfidenceScore(\n            indexToken,\n            \"arbitrum\" // GMX is only on Arbitrum\n        );\n        require(confidenceScore >= MIN_CONFIDENCE_SCORE, \"Confidence too low\");\n        require(signalCount >= 2, \"Need at least 2 signals\");\n        \n        // 4. Open GMX short (USDC must already be on Arbitrum)\n        positionId = _openGMXShort(\n            indexToken,\n            amountUSDC,\n            leverage,\n            acceptablePrice,\n            confidenceScore\n        );\n        \n        return positionId;\n    }\n    \n    \n    /**\n     * @notice Internal function to open GMX perpetual short\n     * @dev This is where the ACTUAL SHORT happens (not just buying the token)\n     */\n    function _openGMXShort(\n        address indexToken,\n        uint256 collateralAmount,\n        uint256 leverage,\n        uint256 acceptablePrice,\n        uint16 confidenceScore\n    ) internal returns (uint256 positionId) {\n        // Calculate position size in USD (GMX uses 30 decimals)\n        // collateralAmount is in USDC (6 decimals), convert to 30 decimals\n        uint256 positionSizeUSD = (collateralAmount * leverage * 1e24); // 6 + 24 = 30 decimals\n        \n        // Approve USDC to GMX Router\n        IERC20(USDC).approve(address(gmxPositionRouter), collateralAmount);\n        \n        // Setup path (just USDC for shorts)\n        address[] memory path = new address[](1);\n        path[0] = USDC;\n        \n        // Create GMX increase position request (SHORT)\n        bytes32 gmxKey = gmxPositionRouter.createIncreasePosition{value: msg.value}(\n            path,\n            indexToken,           // Token to short\n            collateralAmount,     // USDC collateral\n            0,                    // minOut (not needed for shorts)\n            positionSizeUSD,      // Position size with leverage\n            false,                // isLong = FALSE (this is a SHORT!)\n            acceptablePrice,      // Max acceptable entry price\n            msg.value,            // Execution fee for GMX keeper\n            bytes32(0),           // Referral code\n            address(this)         // Callback target\n        );\n        \n        // Create position record\n        positionCounter++;\n        positionId = positionCounter;\n        \n        positions[positionId] = ShortPosition({\n            id: positionId,\n            indexToken: indexToken,\n            collateralUSDC: collateralAmount,\n            positionSizeUSD: positionSizeUSD,\n            leverage: leverage,\n            entryPrice: acceptablePrice,\n            entryTimestamp: block.timestamp,\n            gmxPositionKey: gmxKey,\n            isOpen: true,\n            sourceChain: \"arbitrum\"\n        });\n        \n        // Map GMX key to position ID\n        gmxKeyToPositionId[gmxKey] = positionId;\n        \n        // Record in PositionRegistry\n        bytes32[] memory signalIds = signalOracle.getRecentSignalIds(indexToken, \"arbitrum\");\n        positionRegistry.recordPosition(\n            indexToken,\n            \"arbitrum\",\n            acceptablePrice,\n            (positionSizeUSD * 1e18) / acceptablePrice, // Convert to token amount\n            collateralAmount,\n            confidenceScore,\n            signalIds\n        );\n        \n        emit ShortExecuted(\n            positionId,\n            indexToken,\n            collateralAmount,\n            positionSizeUSD,\n            leverage,\n            confidenceScore,\n            gmxKey\n        );\n        \n        return positionId;\n    }\n    \n    /**\n     * @notice Close a GMX short position\n     * @dev Bridging profits back is handled off-chain by LI.FI SDK\n     * @param positionId Position to close\n     * @param minExitPrice Minimum acceptable exit price (30 decimals)\n     */\n    function closePosition(\n        uint256 positionId,\n        uint256 minExitPrice\n    ) \n        external\n        payable\n        onlyAgent \n        nonReentrant \n    {\n        ShortPosition storage position = positions[positionId];\n        require(position.isOpen, \"Position not open\");\n        require(msg.value >= gmxPositionRouter.minExecutionFee(), \"Insufficient execution fee\");\n        \n        // Setup path for receiving USDC\n        address[] memory path = new address[](1);\n        path[0] = USDC;\n        \n        // Create GMX decrease position request (close SHORT)\n        bytes32 gmxKey = gmxPositionRouter.createDecreasePosition{value: msg.value}(\n            path,\n            position.indexToken,      // Token being shorted\n            position.positionSizeUSD, // Collateral to withdraw (all of it)\n            position.positionSizeUSD, // Position size to close (all of it)\n            false,                    // isLong = false (SHORT)\n            address(this),            // Receiver (USDC stays in vault)\n            minExitPrice,             // Min acceptable exit price for short\n            0,                        // minOut\n            msg.value,                // Execution fee\n            false,                    // withdrawETH\n            address(this)             // Callback target\n        );\n        \n        // Map GMX key to position ID for callback\n        gmxKeyToPositionId[gmxKey] = positionId;\n        \n        emit PositionCloseRequested(positionId, minExitPrice);\n        \n        // Position will be marked closed in GMX callback\n        // Agent can withdraw USDC manually if needed for cross-chain\n    }\n    \n    /**\n     * @notice GMX callback after position execution\n     * @dev Called by GMX Position Router after position is executed\n     */\n    function gmxPositionCallback(\n        bytes32 positionKey,\n        bool isExecuted,\n        bool isIncrease\n    ) external override {\n        require(msg.sender == address(gmxPositionRouter), \"Only GMX Position Router\");\n        \n        uint256 positionId = gmxKeyToPositionId[positionKey];\n        require(positionId > 0, \"Unknown position key\");\n        \n        emit GMXCallbackReceived(positionKey, isExecuted, isIncrease, positionId);\n        \n        if (!isExecuted) {\n            // Position execution failed\n            return;\n        }\n        \n        if (isIncrease) {\n            // Position opened successfully\n            // Already handled in _openGMXShort\n            return;\n        }\n        \n        // Position closed - handle P&L and bridge back\n        ShortPosition storage position = positions[positionId];\n        \n        // Get current USDC balance (includes profit/loss)\n        uint256 finalUSDC = IERC20(USDC).balanceOf(address(this));\n        \n        // Calculate P&L\n        int256 pnlUSDC = int256(finalUSDC) - int256(position.collateralUSDC);\n        \n        // Get exit price from GMX Vault\n        uint256 exitPrice = gmxVault.getMaxPrice(position.indexToken);\n        \n        // Determine status\n        IPositionRegistry.PositionStatus status = pnlUSDC > 0 \n            ? IPositionRegistry.PositionStatus.CLOSED_PROFIT \n            : IPositionRegistry.PositionStatus.CLOSED_LOSS;\n        \n        // Update position registry\n        positionRegistry.closePosition(positionId, exitPrice, status);\n        \n        // Mark position as closed\n        position.isOpen = false;\n        \n        emit PositionClosed(positionId, exitPrice, pnlUSDC, finalUSDC);\n        \n        // USDC remains in vault - agent can withdraw if needed\n    }\n    \n    // ============================================\n    // VIEW FUNCTIONS\n    // ============================================\n    \n    function getTotalVaultValue() public view returns (uint256) {\n        return IERC20(USDC).balanceOf(address(this));\n    }\n    \n    function getOpenPositions() external view returns (ShortPosition[] memory) {\n        // Count open positions\n        uint256 openCount = 0;\n        for (uint256 i = 1; i <= positionCounter; i++) {\n            if (positions[i].isOpen) openCount++;\n        }\n        \n        // Populate array\n        ShortPosition[] memory openPositions = new ShortPosition[](openCount);\n        uint256 index = 0;\n        for (uint256 i = 1; i <= positionCounter; i++) {\n            if (positions[i].isOpen) {\n                openPositions[index] = positions[i];\n                index++;\n            }\n        }\n        \n        return openPositions;\n    }\n    \n    /**\n     * @notice Get GMX position details for a NEXUS position\n     */\n    function getGMXPositionInfo(uint256 positionId) external view returns (\n        uint256 size,\n        uint256 collateral,\n        uint256 averagePrice,\n        bool hasProfit,\n        uint256 delta\n    ) {\n        ShortPosition memory position = positions[positionId];\n        require(position.isOpen, \"Position not open\");\n        \n        // Query GMX Vault\n        (size, collateral, averagePrice, , , , , ) = gmxVault.getPosition(\n            address(this),\n            USDC,\n            position.indexToken,\n            false // isLong = false (SHORT)\n        );\n        \n        // Get unrealised P&L\n        (hasProfit, delta) = gmxVault.getPositionDelta(\n            address(this),\n            USDC,\n            position.indexToken,\n            false\n        );\n        \n        return (size, collateral, averagePrice, hasProfit, delta);\n    }\n    \n    // ============================================\n    // MEMECOIN DIP BUYING FUNCTIONS\n    // ============================================\n    \n    /**\n     * @notice Buy memecoin dip after rug pull for dead cat bounce\n     * @dev Bridging is handled off-chain by LI.FI SDK\n     * @param token Memecoin address on destination chain\n     * @param chain Chain where memecoin lives (e.g., \"base\", \"ethereum\")\n     * @param amountUSDC USDC to spend on dip buy\n     * @param minTokensOut Minimum tokens expected from swap\n     * @param takeProfitPrice Target sell price for bounce (+30-50%)\n     * @param stopLossPrice Stop loss price (-15-20%)\n     * @return positionId Dip buy position ID\n     */\n    function executeDipBuy(\n        address token,\n        string calldata chain,\n        uint256 amountUSDC,\n        uint256 minTokensOut,\n        uint256 takeProfitPrice,\n        uint256 stopLossPrice\n    ) \n        external \n        onlyAgent \n        whenNotPaused \n        nonReentrant \n        returns (uint256 positionId) \n    {\n        // Validate position size (max 5% of vault for dip buys)\n        uint256 vaultBalance = IERC20(USDC).balanceOf(address(this));\n        uint256 maxDipBuySize = (vaultBalance * MAX_DIP_BUY_PERCENT) / 100;\n        require(amountUSDC <= maxDipBuySize, \"Dip buy exceeds max size\");\n        require(amountUSDC <= vaultBalance, \"Insufficient vault balance\");\n        \n        // Validate take-profit and stop-loss\n        require(takeProfitPrice > stopLossPrice, \"Invalid TP/SL prices\");\n        \n        // Bridging handled off-chain by LI.FI SDK\n        // Contract only handles execution on current chain\n        \n        // Create dip buy position record\n        dipBuyCounter++;\n        positionId = dipBuyCounter;\n        \n        dipBuyPositions[positionId] = DipBuyPosition({\n            id: positionId,\n            token: token,\n            chain: chain,\n            entryPrice: 0,  // Will be set after swap executes\n            sizeTokens: 0,  // Will be set after swap executes\n            sizeUSDC: amountUSDC,\n            takeProfitPrice: takeProfitPrice,\n            stopLossPrice: stopLossPrice,\n            entryTimestamp: block.timestamp,\n            isOpen: true,\n            sourceChain: \"arbitrum\"\n        });\n        \n        emit DipBuyInitiated(positionId, token, chain, amountUSDC);\n        \n        return positionId;\n    }\n    \n    /**\n     * @notice Update dip buy position after swap completes\n     * @dev Called by off-chain agent after monitoring swap execution\n     * @param positionId Dip buy position ID\n     * @param tokensReceived Amount of tokens received from swap\n     * @param executionPrice Actual execution price\n     */\n    function updateDipBuyExecution(\n        uint256 positionId,\n        uint256 tokensReceived,\n        uint256 executionPrice\n    ) external onlyAgent {\n        DipBuyPosition storage pos = dipBuyPositions[positionId];\n        require(pos.isOpen, \"Position not open\");\n        require(pos.entryPrice == 0, \"Already executed\");\n        \n        pos.entryPrice = executionPrice;\n        pos.sizeTokens = tokensReceived;\n        \n        emit DipBuyExecuted(positionId, tokensReceived, executionPrice);\n    }\n    \n    /**\n     * @notice Close dip buy position (take profit or stop loss hit)\n     * @param positionId Position to close\n     * @param exitPrice Current market price\n     * @param lifiCalldata LI.FI swap + bridge back calldata\n     */\n    function closeDipBuy(\n        uint256 positionId,\n        uint256 exitPrice,\n        bytes calldata lifiCalldata\n    ) \n        external \n        onlyAgent \n        nonReentrant \n    {\n        DipBuyPosition storage pos = dipBuyPositions[positionId];\n        require(pos.isOpen, \"Position not open\");\n        require(pos.entryPrice > 0, \"Position not executed yet\");\n        \n        // Selling and bridging back handled off-chain by LI.FI SDK\n        // Contract only tracks P&L\n        \n        // Calculate P&L\n        // For dip buys: profit when exitPrice > entryPrice\n        int256 priceDiff = int256(exitPrice) - int256(pos.entryPrice);\n        int256 pnlUSDC = (priceDiff * int256(pos.sizeTokens)) / 1e18;\n        bool isProfit = pnlUSDC > 0;\n        \n        // Mark position as closed\n        pos.isOpen = false;\n        \n        emit DipBuyClosed(positionId, exitPrice, pnlUSDC, isProfit);\n    }\n    \n    /**\n     * @notice Get all open dip buy positions\n     */\n    function getOpenDipBuys() external view returns (DipBuyPosition[] memory) {\n        // Count open dip buys\n        uint256 openCount = 0;\n        for (uint256 i = 1; i <= dipBuyCounter; i++) {\n            if (dipBuyPositions[i].isOpen) openCount++;\n        }\n        \n        // Populate array\n        DipBuyPosition[] memory openDipBuys = new DipBuyPosition[](openCount);\n        uint256 index = 0;\n        for (uint256 i = 1; i <= dipBuyCounter; i++) {\n            if (dipBuyPositions[i].isOpen) {\n                openDipBuys[index] = dipBuyPositions[i];\n                index++;\n            }\n        }\n        \n        return openDipBuys;\n    }\n    \n    // ============================================\n    // ADMIN FUNCTIONS\n    // ============================================\n    \n    function setAgentAddress(address newAgent) external onlyOwner {\n        require(newAgent != address(0), \"Invalid agent\");\n        address oldAgent = agentAddress;\n        agentAddress = newAgent;\n        emit AgentUpdated(oldAgent, newAgent);\n    }\n    \n    function approveToken(address token, bool approved) external onlyOwner {\n        approvedTokens[token] = approved;\n        emit TokenApproved(token, approved);\n    }\n    \n    function approveChain(string calldata chain, bool approved) external onlyOwner {\n        approvedChains[chain] = approved;\n        emit ChainApproved(chain, approved);\n    }\n    \n    function setPaused(bool _paused) external onlyOwner {\n        paused = _paused;\n    }\n    \n    function updateSignalOracle(address newOracle) external onlyOwner {\n        require(newOracle != address(0), \"Invalid oracle\");\n        signalOracle = ISignalOracle(newOracle);\n    }\n    \n    function updatePositionRegistry(address newRegistry) external onlyOwner {\n        require(newRegistry != address(0), \"Invalid registry\");\n        positionRegistry = IPositionRegistry(newRegistry);\n    }\n    \n    function updatePriceOracle(address newPriceOracle) external onlyOwner {\n        require(newPriceOracle != address(0), \"Invalid oracle\");\n        priceOracle = IPriceOracle(newPriceOracle);\n    }\n    \n    /**\n     * @notice Emergency withdraw - only callable if paused for >48 hours\n     */\n    function emergencyWithdraw(address token, uint256 amount) external onlyOwner {\n        require(paused, \"Must be paused\");\n        // Additional safety: could add a pausedTimestamp check\n        \n        IERC20(token).transfer(owner(), amount);\n        emit EmergencyWithdraw(token, amount);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}