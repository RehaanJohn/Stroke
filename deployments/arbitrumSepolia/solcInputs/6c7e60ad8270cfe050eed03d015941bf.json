{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "contracts/interfaces/IGMXPositionRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IGMXPositionRouter\n * @notice Interface for GMX Position Router for opening/closing leveraged positions\n * @dev Used to execute perpetual shorts on GMX\n */\ninterface IGMXPositionRouter {\n    /**\n     * @notice Create an increase position request (open or add to position)\n     * @param _path Token path for collateral (e.g., [USDC])\n     * @param _indexToken Token to long/short (e.g., WETH, WBTC)\n     * @param _amountIn Collateral amount\n     * @param _minOut Minimum tokens out (0 for shorts)\n     * @param _sizeDelta Position size increase in USD (30 decimals)\n     * @param _isLong true for long, false for short\n     * @param _acceptablePrice Max price for longs, min price for shorts (30 decimals)\n     * @param _executionFee Fee paid to keeper (msg.value)\n     * @param _referralCode Referral code for fee sharing\n     * @param _callbackTarget Address to call after execution\n     * @return requestKey Unique identifier for this position request\n     */\n    function createIncreasePosition(\n        address[] memory _path,\n        address _indexToken,\n        uint256 _amountIn,\n        uint256 _minOut,\n        uint256 _sizeDelta,\n        bool _isLong,\n        uint256 _acceptablePrice,\n        uint256 _executionFee,\n        bytes32 _referralCode,\n        address _callbackTarget\n    ) external payable returns (bytes32 requestKey);\n\n    /**\n     * @notice Create a decrease position request (close or reduce position)\n     * @param _path Token path for receiving collateral (e.g., [USDC])\n     * @param _indexToken Token being shorted/longed\n     * @param _collateralDelta Collateral to withdraw in USD (30 decimals)\n     * @param _sizeDelta Position size to decrease in USD (30 decimals)\n     * @param _isLong true for long, false for short\n     * @param _receiver Address to receive withdrawn collateral\n     * @param _acceptablePrice Min price for longs, max price for shorts (30 decimals)\n     * @param _minOut Minimum tokens to receive\n     * @param _executionFee Fee paid to keeper (msg.value)\n     * @param _withdrawETH Whether to withdraw as ETH instead of WETH\n     * @param _callbackTarget Address to call after execution\n     * @return requestKey Unique identifier for this position request\n     */\n    function createDecreasePosition(\n        address[] memory _path,\n        address _indexToken,\n        uint256 _collateralDelta,\n        uint256 _sizeDelta,\n        bool _isLong,\n        address _receiver,\n        uint256 _acceptablePrice,\n        uint256 _minOut,\n        uint256 _executionFee,\n        bool _withdrawETH,\n        address _callbackTarget\n    ) external payable returns (bytes32 requestKey);\n\n    /**\n     * @notice Get minimum execution fee required\n     */\n    function minExecutionFee() external view returns (uint256);\n\n    /**\n     * @notice Get position request by key\n     */\n    function increasePositionRequests(bytes32 key) external view returns (\n        address account,\n        address[] memory path,\n        address indexToken,\n        uint256 amountIn,\n        uint256 minOut,\n        uint256 sizeDelta,\n        bool isLong,\n        uint256 acceptablePrice,\n        uint256 executionFee,\n        uint256 blockNumber,\n        uint256 blockTime,\n        bool hasCollateralInETH,\n        address callbackTarget\n    );\n\n    /**\n     * @notice Get decrease position request by key\n     */\n    function decreasePositionRequests(bytes32 key) external view returns (\n        address account,\n        address[] memory path,\n        address indexToken,\n        uint256 collateralDelta,\n        uint256 sizeDelta,\n        bool isLong,\n        address receiver,\n        uint256 acceptablePrice,\n        uint256 minOut,\n        uint256 executionFee,\n        uint256 blockNumber,\n        uint256 blockTime,\n        bool withdrawETH,\n        address callbackTarget\n    );\n\n    /**\n     * @notice Cancel an increase position request\n     */\n    function cancelIncreasePosition(\n        bytes32 _key,\n        address payable _executionFeeReceiver\n    ) external returns (bool);\n\n    /**\n     * @notice Cancel a decrease position request\n     */\n    function cancelDecreasePosition(\n        bytes32 _key,\n        address payable _executionFeeReceiver\n    ) external returns (bool);\n}\n"
    },
    "contracts/interfaces/IGMXPositionRouterCallbackReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IGMXPositionRouterCallbackReceiver\n * @notice Interface for receiving callbacks from GMX Position Router\n * @dev Implement this to handle position execution confirmations\n */\ninterface IGMXPositionRouterCallbackReceiver {\n    /**\n     * @notice Called by GMX Position Router after position is executed\n     * @param positionKey Unique key identifying the position request\n     * @param isExecuted true if position was successfully executed\n     * @param isIncrease true for increase position, false for decrease\n     */\n    function gmxPositionCallback(\n        bytes32 positionKey,\n        bool isExecuted,\n        bool isIncrease\n    ) external;\n}\n"
    },
    "contracts/interfaces/IGMXVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IGMXVault\n * @notice Interface for GMX Vault to query positions\n * @dev Used to read position data and validate state\n */\ninterface IGMXVault {\n    /**\n     * @notice Get position details\n     * @param _account Position owner\n     * @param _collateralToken Collateral token address\n     * @param _indexToken Token being shorted/longed\n     * @param _isLong true for long, false for short\n     * @return size Position size in USD (30 decimals)\n     * @return collateral Collateral amount in USD (30 decimals)\n     * @return averagePrice Average entry price (30 decimals)\n     * @return entryFundingRate Funding rate at entry\n     * @return reserveAmount Reserved amount\n     * @return realisedPnl Realised P&L\n     * @return hasProfit Whether position has unrealised profit\n     * @return lastIncreasedTime Last time position was increased\n     */\n    function getPosition(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        bool _isLong\n    ) external view returns (\n        uint256 size,\n        uint256 collateral,\n        uint256 averagePrice,\n        uint256 entryFundingRate,\n        uint256 reserveAmount,\n        uint256 realisedPnl,\n        bool hasProfit,\n        uint256 lastIncreasedTime\n    );\n\n    /**\n     * @notice Get position delta (unrealised P&L)\n     * @return hasProfit Whether position is profitable\n     * @return delta Absolute P&L amount\n     */\n    function getPositionDelta(\n        address _account,\n        address _collateralToken,\n        address _indexToken,\n        bool _isLong\n    ) external view returns (bool hasProfit, uint256 delta);\n\n    /**\n     * @notice Get current price of token\n     */\n    function getMaxPrice(address _token) external view returns (uint256);\n    \n    /**\n     * @notice Get minimum price of token\n     */\n    function getMinPrice(address _token) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IPositionRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IPositionRegistry {\n    enum PositionStatus {\n        OPEN,\n        CLOSED_PROFIT,\n        CLOSED_LOSS,\n        CLOSED_STOP_LOSS,\n        LIQUIDATED\n    }\n    \n    function recordPosition(\n        address tokenAddress,\n        string calldata chain,\n        uint256 entryPrice,\n        uint256 sizeTokens,\n        uint256 sizeUSDC,\n        uint16 confidenceScore,\n        bytes32[] calldata triggeringSignals\n    ) external returns (uint256 positionId);\n    \n    function closePosition(\n        uint256 positionId,\n        uint256 exitPrice,\n        PositionStatus finalStatus\n    ) external;\n}\n"
    },
    "contracts/interfaces/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IPriceOracle {\n    function getPrice(\n        address tokenAddress,\n        string calldata chain\n    ) external view returns (uint256 price);\n}\n"
    },
    "contracts/interfaces/ISignalOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface ISignalOracle {\n    enum SignalType {\n        INSIDER_WALLET_DUMP,\n        LIQUIDITY_REMOVAL,\n        TWITTER_ENGAGEMENT_DROP,\n        TWITTER_SENTIMENT_NEGATIVE,\n        GOVERNANCE_BEARISH,\n        GITHUB_COMMIT_DROP,\n        DEVELOPER_EXODUS,\n        WHALE_ALERT,\n        REGULATORY_RISK,\n        MACRO_EVENT,\n        INSTITUTIONAL_MOVE,\n        SENTIMENT_SHIFT\n    }\n    \n    function getConfidenceScore(\n        address tokenAddress,\n        string calldata chain\n    ) external view returns (uint16 totalScore, uint8 signalCount);\n    \n    function getRecentSignalIds(\n        address tokenAddress,\n        string calldata chain\n    ) external view returns (bytes32[] memory);\n}\n"
    },
    "contracts/NexusVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./interfaces/ISignalOracle.sol\";\nimport \"./interfaces/IPositionRegistry.sol\";\nimport \"./interfaces/IPriceOracle.sol\";\nimport \"./interfaces/IGMXPositionRouter.sol\";\nimport \"./interfaces/IGMXVault.sol\";\nimport \"./interfaces/IGMXPositionRouterCallbackReceiver.sol\";\n\n/**\n * @title NexusVault\n * @notice Main execution contract for cross-chain autonomous shorts via LI.FI + GMX\n * @dev Holds USDC treasury, bridges via LI.FI, executes perpetual shorts on GMX\n * \n * Architecture:\n * 1. User funds on any chain → LI.FI bridges to Arbitrum\n * 2. On Arbitrum, opens GMX perpetual SHORT position\n * 3. Price crashes, GMX SHORT profits\n * 4. Close position, bridge profits back via LI.FI\n */\ncontract NexusVault is Ownable, ReentrancyGuard, IGMXPositionRouterCallbackReceiver {\n    // ============================================\n    // STATE VARIABLES\n    // ============================================\n    \n    address public immutable USDC;\n    address public agentAddress;\n    \n    ISignalOracle public signalOracle;\n    IPositionRegistry public positionRegistry;\n    IPriceOracle public priceOracle;\n    IGMXPositionRouter public gmxPositionRouter;\n    IGMXVault public gmxVault;\n    \n    bool public paused;\n    uint256 public constant MAX_POSITION_PERCENT = 20; // Max 20% of vault in one position\n    uint256 public constant MIN_CONFIDENCE_SCORE = 70; // Minimum 70/100 confidence\n    uint256 public constant DEFAULT_LEVERAGE = 2; // 2x leverage (can be 1-50x on GMX)\n    uint256 public constant GMX_PRICE_PRECISION = 1e30; // GMX uses 30 decimals for USD\n    \n    // Approved tokens for shorting (whitelist to prevent scams)\n    mapping(address => bool) public approvedTokens;\n    \n    // Chain whitelist (must be \"arbitrum\" for GMX)\n    mapping(string => bool) public approvedChains;\n    \n    // Position tracking\n    mapping(uint256 => ShortPosition) public positions;\n    uint256 public positionCounter;\n    \n    // GMX position key → NEXUS position ID\n    mapping(bytes32 => uint256) public gmxKeyToPositionId;\n    \n    // Position ID → Pending bridge back request\n    mapping(uint256 => BridgeBackRequest) public pendingBridgeBack;\n    \n    // Dip buy positions (memecoin post-rug buys)\n    mapping(uint256 => DipBuyPosition) public dipBuyPositions;\n    uint256 public dipBuyCounter;\n    \n    uint256 public constant MAX_DIP_BUY_PERCENT = 5; // Max 5% of vault on dip buys\n    \n    struct ShortPosition {\n        uint256 id;\n        address indexToken;      // Token being shorted (e.g., WETH, WBTC)\n        uint256 collateralUSDC;  // USDC collateral amount\n        uint256 positionSizeUSD; // Position size in USD (30 decimals)\n        uint256 leverage;        // Leverage multiplier\n        uint256 entryPrice;      // Entry price (30 decimals)\n        uint256 entryTimestamp;\n        bytes32 gmxPositionKey;  // GMX request key\n        bool isOpen;\n        string sourceChain;      // Original chain funds came from\n    }\n    \n    struct BridgeBackRequest {\n        string destinationChain;\n        address recipient;\n        uint256 timestamp;\n    }\n    \n    struct DipBuyPosition {\n        uint256 id;\n        address token;           // Memecoin being bought\n        string chain;            // Chain where token lives\n        uint256 entryPrice;      // Buy price (18 decimals)\n        uint256 sizeTokens;      // Amount of tokens bought\n        uint256 sizeUSDC;        // USDC spent\n        uint256 takeProfitPrice; // Target sell price (+30-50%)\n        uint256 stopLossPrice;   // Stop loss price (-15%)\n        uint256 entryTimestamp;\n        bool isOpen;\n        string sourceChain;      // Original chain funds came from\n    }\n    \n    // ============================================\n    // EVENTS\n    // ============================================\n    \n    event BridgeInitiated(\n        string indexed sourceChain,\n        uint256 amountUSDC,\n        bytes32 lifiTransferId\n    );\n    \n    event LiFiBridgeExecuted(\n        bytes32 indexed transactionId,\n        string sourceChain,\n        uint256 destinationChainId,\n        uint256 amountUSDC\n    );\n    \n    event ShortExecuted(\n        uint256 indexed positionId,\n        address indexed indexToken,\n        uint256 collateralUSDC,\n        uint256 positionSizeUSD,\n        uint256 leverage,\n        uint16 confidenceScore,\n        bytes32 gmxPositionKey\n    );\n    \n    event PositionClosed(\n        uint256 indexed positionId,\n        uint256 exitPrice,\n        int256 pnlUSDC,\n        uint256 finalUSDC\n    );\n    \n    event GMXCallbackReceived(\n        bytes32 indexed positionKey,\n        bool isExecuted,\n        bool isIncrease,\n        uint256 nexusPositionId\n    );\n    \n    event BridgeBackInitiated(\n        uint256 indexed positionId,\n        string destinationChain,\n        uint256 amountUSDC\n    );\n    \n    event DipBuyInitiated(\n        uint256 indexed positionId,\n        address indexed token,\n        string chain,\n        uint256 amountUSDC\n    );\n    \n    event DipBuyExecuted(\n        uint256 indexed positionId,\n        uint256 tokensReceived,\n        uint256 executionPrice\n    );\n    \n    event DipBuyClosed(\n        uint256 indexed positionId,\n        uint256 exitPrice,\n        int256 pnlUSDC,\n        bool isProfit\n    );\n    \n    event TokenApproved(address indexed token, bool approved);\n    event ChainApproved(string chain, bool approved);\n    event AgentUpdated(address indexed oldAgent, address indexed newAgent);\n    event EmergencyWithdraw(address indexed token, uint256 amount);\n    event PositionCloseRequested(uint256 indexed positionId, uint256 minExitPrice);\n    \n    // ============================================\n    // MODIFIERS\n    // ============================================\n    \n    modifier onlyAgent() {\n        require(msg.sender == agentAddress, \"Not authorized agent\");\n        _;\n    }\n    \n    modifier whenNotPaused() {\n        require(!paused, \"Vault is paused\");\n        _;\n    }\n    \n    // ============================================\n    // CONSTRUCTOR\n    // ============================================\n    \n    constructor(\n        address _usdc,\n        address _agentAddress,\n        address _signalOracle,\n        address _positionRegistry,\n        address _priceOracle,\n        address _gmxPositionRouter,\n        address _gmxVault\n    ) Ownable(msg.sender) {\n        USDC = _usdc;\n        agentAddress = _agentAddress;\n        signalOracle = ISignalOracle(_signalOracle);\n        positionRegistry = IPositionRegistry(_positionRegistry);\n        priceOracle = IPriceOracle(_priceOracle);\n        gmxPositionRouter = IGMXPositionRouter(_gmxPositionRouter);\n        gmxVault = IGMXVault(_gmxVault);\n        \n        // Only Arbitrum is approved (GMX is only on Arbitrum)\n        approvedChains[\"arbitrum\"] = true;\n    }\n    \n    // ============================================\n    // CORE FUNCTIONS\n    // ============================================\n    \n    /**\n     * @notice Execute a GMX short position (USDC must already be on Arbitrum)\n     * @dev Cross-chain bridging is handled off-chain by LI.FI SDK (TypeScript)\n     *      This contract only opens GMX shorts with USDC already on Arbitrum\n     * \n     * @param indexToken Token to short (e.g., WETH, WBTC)\n     * @param amountUSDC Collateral amount in USDC (6 decimals)\n     * @param leverage Leverage multiplier (1-50x, typically 2-10x)\n     * @param acceptablePrice Maximum entry price for short (30 decimals)\n     * @return positionId The ID of the created position\n     */\n    function executeShort(\n        address indexToken,\n        uint256 amountUSDC,\n        uint256 leverage,\n        uint256 acceptablePrice\n    ) \n        external \n        payable\n        onlyAgent \n        whenNotPaused \n        nonReentrant \n        returns (uint256 positionId) \n    {\n        // 1. Validate inputs\n        require(approvedTokens[indexToken], \"Token not approved\");\n        require(leverage >= 1 && leverage <= 50, \"Invalid leverage\");\n        require(msg.value >= gmxPositionRouter.minExecutionFee(), \"Insufficient execution fee\");\n        \n        // 2. Check position limits (max 20% of vault)\n        uint256 vaultBalance = IERC20(USDC).balanceOf(address(this));\n        uint256 maxPositionSize = (vaultBalance * MAX_POSITION_PERCENT) / 100;\n        require(amountUSDC <= maxPositionSize, \"Position exceeds max size\");\n        require(amountUSDC <= vaultBalance, \"Insufficient vault balance\");\n        \n        // 3. Get confidence from SignalOracle\n        (uint16 confidenceScore, uint8 signalCount) = signalOracle.getConfidenceScore(\n            indexToken,\n            \"arbitrum\" // GMX is only on Arbitrum\n        );\n        require(confidenceScore >= MIN_CONFIDENCE_SCORE, \"Confidence too low\");\n        require(signalCount >= 2, \"Need at least 2 signals\");\n        \n        // 4. Open GMX short (USDC must already be on Arbitrum)\n        positionId = _openGMXShort(\n            indexToken,\n            amountUSDC,\n            leverage,\n            acceptablePrice,\n            confidenceScore\n        );\n        \n        return positionId;\n    }\n    \n    \n    /**\n     * @notice Internal function to open GMX perpetual short\n     * @dev This is where the ACTUAL SHORT happens (not just buying the token)\n     */\n    function _openGMXShort(\n        address indexToken,\n        uint256 collateralAmount,\n        uint256 leverage,\n        uint256 acceptablePrice,\n        uint16 confidenceScore\n    ) internal returns (uint256 positionId) {\n        // Calculate position size in USD (GMX uses 30 decimals)\n        // collateralAmount is in USDC (6 decimals), convert to 30 decimals\n        uint256 positionSizeUSD = (collateralAmount * leverage * 1e24); // 6 + 24 = 30 decimals\n        \n        // Approve USDC to GMX Router\n        IERC20(USDC).approve(address(gmxPositionRouter), collateralAmount);\n        \n        // Setup path (just USDC for shorts)\n        address[] memory path = new address[](1);\n        path[0] = USDC;\n        \n        // Create GMX increase position request (SHORT)\n        bytes32 gmxKey = gmxPositionRouter.createIncreasePosition{value: msg.value}(\n            path,\n            indexToken,           // Token to short\n            collateralAmount,     // USDC collateral\n            0,                    // minOut (not needed for shorts)\n            positionSizeUSD,      // Position size with leverage\n            false,                // isLong = FALSE (this is a SHORT!)\n            acceptablePrice,      // Max acceptable entry price\n            msg.value,            // Execution fee for GMX keeper\n            bytes32(0),           // Referral code\n            address(this)         // Callback target\n        );\n        \n        // Create position record\n        positionCounter++;\n        positionId = positionCounter;\n        \n        positions[positionId] = ShortPosition({\n            id: positionId,\n            indexToken: indexToken,\n            collateralUSDC: collateralAmount,\n            positionSizeUSD: positionSizeUSD,\n            leverage: leverage,\n            entryPrice: acceptablePrice,\n            entryTimestamp: block.timestamp,\n            gmxPositionKey: gmxKey,\n            isOpen: true,\n            sourceChain: \"arbitrum\"\n        });\n        \n        // Map GMX key to position ID\n        gmxKeyToPositionId[gmxKey] = positionId;\n        \n        // Record in PositionRegistry\n        bytes32[] memory signalIds = signalOracle.getRecentSignalIds(indexToken, \"arbitrum\");\n        positionRegistry.recordPosition(\n            indexToken,\n            \"arbitrum\",\n            acceptablePrice,\n            (positionSizeUSD * 1e18) / acceptablePrice, // Convert to token amount\n            collateralAmount,\n            confidenceScore,\n            signalIds\n        );\n        \n        emit ShortExecuted(\n            positionId,\n            indexToken,\n            collateralAmount,\n            positionSizeUSD,\n            leverage,\n            confidenceScore,\n            gmxKey\n        );\n        \n        return positionId;\n    }\n    \n    /**\n     * @notice Close a GMX short position\n     * @dev Bridging profits back is handled off-chain by LI.FI SDK\n     * @param positionId Position to close\n     * @param minExitPrice Minimum acceptable exit price (30 decimals)\n     */\n    function closePosition(\n        uint256 positionId,\n        uint256 minExitPrice\n    ) \n        external\n        payable\n        onlyAgent \n        nonReentrant \n    {\n        ShortPosition storage position = positions[positionId];\n        require(position.isOpen, \"Position not open\");\n        require(msg.value >= gmxPositionRouter.minExecutionFee(), \"Insufficient execution fee\");\n        \n        // Setup path for receiving USDC\n        address[] memory path = new address[](1);\n        path[0] = USDC;\n        \n        // Create GMX decrease position request (close SHORT)\n        bytes32 gmxKey = gmxPositionRouter.createDecreasePosition{value: msg.value}(\n            path,\n            position.indexToken,      // Token being shorted\n            position.positionSizeUSD, // Collateral to withdraw (all of it)\n            position.positionSizeUSD, // Position size to close (all of it)\n            false,                    // isLong = false (SHORT)\n            address(this),            // Receiver (USDC stays in vault)\n            minExitPrice,             // Min acceptable exit price for short\n            0,                        // minOut\n            msg.value,                // Execution fee\n            false,                    // withdrawETH\n            address(this)             // Callback target\n        );\n        \n        // Map GMX key to position ID for callback\n        gmxKeyToPositionId[gmxKey] = positionId;\n        \n        emit PositionCloseRequested(positionId, minExitPrice);\n        \n        // Position will be marked closed in GMX callback\n        // Agent can withdraw USDC manually if needed for cross-chain\n    }\n    \n    /**\n     * @notice GMX callback after position execution\n     * @dev Called by GMX Position Router after position is executed\n     */\n    function gmxPositionCallback(\n        bytes32 positionKey,\n        bool isExecuted,\n        bool isIncrease\n    ) external override {\n        require(msg.sender == address(gmxPositionRouter), \"Only GMX Position Router\");\n        \n        uint256 positionId = gmxKeyToPositionId[positionKey];\n        require(positionId > 0, \"Unknown position key\");\n        \n        emit GMXCallbackReceived(positionKey, isExecuted, isIncrease, positionId);\n        \n        if (!isExecuted) {\n            // Position execution failed\n            return;\n        }\n        \n        if (isIncrease) {\n            // Position opened successfully\n            // Already handled in _openGMXShort\n            return;\n        }\n        \n        // Position closed - handle P&L and bridge back\n        ShortPosition storage position = positions[positionId];\n        \n        // Get current USDC balance (includes profit/loss)\n        uint256 finalUSDC = IERC20(USDC).balanceOf(address(this));\n        \n        // Calculate P&L\n        int256 pnlUSDC = int256(finalUSDC) - int256(position.collateralUSDC);\n        \n        // Get exit price from GMX Vault\n        uint256 exitPrice = gmxVault.getMaxPrice(position.indexToken);\n        \n        // Determine status\n        IPositionRegistry.PositionStatus status = pnlUSDC > 0 \n            ? IPositionRegistry.PositionStatus.CLOSED_PROFIT \n            : IPositionRegistry.PositionStatus.CLOSED_LOSS;\n        \n        // Update position registry\n        positionRegistry.closePosition(positionId, exitPrice, status);\n        \n        // Mark position as closed\n        position.isOpen = false;\n        \n        emit PositionClosed(positionId, exitPrice, pnlUSDC, finalUSDC);\n        \n        // USDC remains in vault - agent can withdraw if needed\n    }\n    \n    // ============================================\n    // VIEW FUNCTIONS\n    // ============================================\n    \n    function getTotalVaultValue() public view returns (uint256) {\n        return IERC20(USDC).balanceOf(address(this));\n    }\n    \n    function getOpenPositions() external view returns (ShortPosition[] memory) {\n        // Count open positions\n        uint256 openCount = 0;\n        for (uint256 i = 1; i <= positionCounter; i++) {\n            if (positions[i].isOpen) openCount++;\n        }\n        \n        // Populate array\n        ShortPosition[] memory openPositions = new ShortPosition[](openCount);\n        uint256 index = 0;\n        for (uint256 i = 1; i <= positionCounter; i++) {\n            if (positions[i].isOpen) {\n                openPositions[index] = positions[i];\n                index++;\n            }\n        }\n        \n        return openPositions;\n    }\n    \n    /**\n     * @notice Get GMX position details for a NEXUS position\n     */\n    function getGMXPositionInfo(uint256 positionId) external view returns (\n        uint256 size,\n        uint256 collateral,\n        uint256 averagePrice,\n        bool hasProfit,\n        uint256 delta\n    ) {\n        ShortPosition memory position = positions[positionId];\n        require(position.isOpen, \"Position not open\");\n        \n        // Query GMX Vault\n        (size, collateral, averagePrice, , , , , ) = gmxVault.getPosition(\n            address(this),\n            USDC,\n            position.indexToken,\n            false // isLong = false (SHORT)\n        );\n        \n        // Get unrealised P&L\n        (hasProfit, delta) = gmxVault.getPositionDelta(\n            address(this),\n            USDC,\n            position.indexToken,\n            false\n        );\n        \n        return (size, collateral, averagePrice, hasProfit, delta);\n    }\n    \n    // ============================================\n    // MEMECOIN DIP BUYING FUNCTIONS\n    // ============================================\n    \n    /**\n     * @notice Buy memecoin dip after rug pull for dead cat bounce\n     * @dev Bridging is handled off-chain by LI.FI SDK\n     * @param token Memecoin address on destination chain\n     * @param chain Chain where memecoin lives (e.g., \"base\", \"ethereum\")\n     * @param amountUSDC USDC to spend on dip buy\n     * @param minTokensOut Minimum tokens expected from swap\n     * @param takeProfitPrice Target sell price for bounce (+30-50%)\n     * @param stopLossPrice Stop loss price (-15-20%)\n     * @return positionId Dip buy position ID\n     */\n    function executeDipBuy(\n        address token,\n        string calldata chain,\n        uint256 amountUSDC,\n        uint256 minTokensOut,\n        uint256 takeProfitPrice,\n        uint256 stopLossPrice\n    ) \n        external \n        onlyAgent \n        whenNotPaused \n        nonReentrant \n        returns (uint256 positionId) \n    {\n        // Validate position size (max 5% of vault for dip buys)\n        uint256 vaultBalance = IERC20(USDC).balanceOf(address(this));\n        uint256 maxDipBuySize = (vaultBalance * MAX_DIP_BUY_PERCENT) / 100;\n        require(amountUSDC <= maxDipBuySize, \"Dip buy exceeds max size\");\n        require(amountUSDC <= vaultBalance, \"Insufficient vault balance\");\n        \n        // Validate take-profit and stop-loss\n        require(takeProfitPrice > stopLossPrice, \"Invalid TP/SL prices\");\n        \n        // Bridging handled off-chain by LI.FI SDK\n        // Contract only handles execution on current chain\n        \n        // Create dip buy position record\n        dipBuyCounter++;\n        positionId = dipBuyCounter;\n        \n        dipBuyPositions[positionId] = DipBuyPosition({\n            id: positionId,\n            token: token,\n            chain: chain,\n            entryPrice: 0,  // Will be set after swap executes\n            sizeTokens: 0,  // Will be set after swap executes\n            sizeUSDC: amountUSDC,\n            takeProfitPrice: takeProfitPrice,\n            stopLossPrice: stopLossPrice,\n            entryTimestamp: block.timestamp,\n            isOpen: true,\n            sourceChain: \"arbitrum\"\n        });\n        \n        emit DipBuyInitiated(positionId, token, chain, amountUSDC);\n        \n        return positionId;\n    }\n    \n    /**\n     * @notice Update dip buy position after swap completes\n     * @dev Called by off-chain agent after monitoring swap execution\n     * @param positionId Dip buy position ID\n     * @param tokensReceived Amount of tokens received from swap\n     * @param executionPrice Actual execution price\n     */\n    function updateDipBuyExecution(\n        uint256 positionId,\n        uint256 tokensReceived,\n        uint256 executionPrice\n    ) external onlyAgent {\n        DipBuyPosition storage pos = dipBuyPositions[positionId];\n        require(pos.isOpen, \"Position not open\");\n        require(pos.entryPrice == 0, \"Already executed\");\n        \n        pos.entryPrice = executionPrice;\n        pos.sizeTokens = tokensReceived;\n        \n        emit DipBuyExecuted(positionId, tokensReceived, executionPrice);\n    }\n    \n    /**\n     * @notice Close dip buy position (take profit or stop loss hit)\n     * @param positionId Position to close\n     * @param exitPrice Current market price\n     * @param lifiCalldata LI.FI swap + bridge back calldata\n     */\n    function closeDipBuy(\n        uint256 positionId,\n        uint256 exitPrice,\n        bytes calldata lifiCalldata\n    ) \n        external \n        onlyAgent \n        nonReentrant \n    {\n        DipBuyPosition storage pos = dipBuyPositions[positionId];\n        require(pos.isOpen, \"Position not open\");\n        require(pos.entryPrice > 0, \"Position not executed yet\");\n        \n        // Selling and bridging back handled off-chain by LI.FI SDK\n        // Contract only tracks P&L\n        \n        // Calculate P&L\n        // For dip buys: profit when exitPrice > entryPrice\n        int256 priceDiff = int256(exitPrice) - int256(pos.entryPrice);\n        int256 pnlUSDC = (priceDiff * int256(pos.sizeTokens)) / 1e18;\n        bool isProfit = pnlUSDC > 0;\n        \n        // Mark position as closed\n        pos.isOpen = false;\n        \n        emit DipBuyClosed(positionId, exitPrice, pnlUSDC, isProfit);\n    }\n    \n    /**\n     * @notice Get all open dip buy positions\n     */\n    function getOpenDipBuys() external view returns (DipBuyPosition[] memory) {\n        // Count open dip buys\n        uint256 openCount = 0;\n        for (uint256 i = 1; i <= dipBuyCounter; i++) {\n            if (dipBuyPositions[i].isOpen) openCount++;\n        }\n        \n        // Populate array\n        DipBuyPosition[] memory openDipBuys = new DipBuyPosition[](openCount);\n        uint256 index = 0;\n        for (uint256 i = 1; i <= dipBuyCounter; i++) {\n            if (dipBuyPositions[i].isOpen) {\n                openDipBuys[index] = dipBuyPositions[i];\n                index++;\n            }\n        }\n        \n        return openDipBuys;\n    }\n    \n    // ============================================\n    // ADMIN FUNCTIONS\n    // ============================================\n    \n    function setAgentAddress(address newAgent) external onlyOwner {\n        require(newAgent != address(0), \"Invalid agent\");\n        address oldAgent = agentAddress;\n        agentAddress = newAgent;\n        emit AgentUpdated(oldAgent, newAgent);\n    }\n    \n    function approveToken(address token, bool approved) external onlyOwner {\n        approvedTokens[token] = approved;\n        emit TokenApproved(token, approved);\n    }\n    \n    function approveChain(string calldata chain, bool approved) external onlyOwner {\n        approvedChains[chain] = approved;\n        emit ChainApproved(chain, approved);\n    }\n    \n    function setPaused(bool _paused) external onlyOwner {\n        paused = _paused;\n    }\n    \n    function updateSignalOracle(address newOracle) external onlyOwner {\n        require(newOracle != address(0), \"Invalid oracle\");\n        signalOracle = ISignalOracle(newOracle);\n    }\n    \n    function updatePositionRegistry(address newRegistry) external onlyOwner {\n        require(newRegistry != address(0), \"Invalid registry\");\n        positionRegistry = IPositionRegistry(newRegistry);\n    }\n    \n    function updatePriceOracle(address newPriceOracle) external onlyOwner {\n        require(newPriceOracle != address(0), \"Invalid oracle\");\n        priceOracle = IPriceOracle(newPriceOracle);\n    }\n    \n    /**\n     * @notice Emergency withdraw - only callable if paused for >48 hours\n     */\n    function emergencyWithdraw(address token, uint256 amount) external onlyOwner {\n        require(paused, \"Must be paused\");\n        // Additional safety: could add a pausedTimestamp check\n        \n        IERC20(token).transfer(owner(), amount);\n        emit EmergencyWithdraw(token, amount);\n    }\n}\n"
    },
    "contracts/PositionRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title PositionRegistry\n * @notice On-chain ledger of all shorts with P&L tracking\n * @dev Provides transparent, auditable performance metrics\n */\ncontract PositionRegistry is Ownable {\n    // ============================================\n    // ENUMS & STRUCTS\n    // ============================================\n    \n    enum PositionStatus {\n        OPEN,\n        CLOSED_PROFIT,\n        CLOSED_LOSS,\n        CLOSED_STOP_LOSS,\n        LIQUIDATED\n    }\n    \n    struct Position {\n        uint256 id;\n        address tokenAddress;\n        string chain;\n        \n        // Entry data\n        uint256 entryPrice;\n        uint256 entryTimestamp;\n        uint256 sizeTokens;\n        uint256 sizeUSDC;\n        \n        // Exit data\n        uint256 exitPrice;\n        uint256 exitTimestamp;\n        int256 pnlUSDC;\n        \n        // Metadata\n        uint16 confidenceScore;\n        bytes32[] triggeringSignals;\n        \n        PositionStatus status;\n    }\n    \n    struct DipBuyPosition {\n        uint256 id;\n        address tokenAddress;\n        string chain;\n        \n        // Entry data\n        uint256 entryPrice;\n        uint256 entryTimestamp;\n        uint256 sizeTokens;\n        uint256 sizeUSDC;\n        \n        // Exit data\n        uint256 exitPrice;\n        uint256 exitTimestamp;\n        int256 pnlUSDC;\n        \n        // Targets\n        uint256 takeProfitPrice;\n        uint256 stopLossPrice;\n        \n        // Metadata\n        uint16 confidenceScore;\n        \n        PositionStatus status;\n    }\n    \n    struct PerformanceMetrics {\n        uint256 totalPositions;\n        uint256 closedPositions;\n        uint256 profitablePositions;\n        int256 totalPnLUSDC;\n        uint256 totalVolumeUSDC;\n        \n        // Calculated fields\n        uint16 winRatePercent; // profitablePositions / closedPositions * 10000\n        int256 averagePnL;\n        int256 largestWin;\n        int256 largestLoss;\n    }\n    \n    // ============================================\n    // STATE VARIABLES\n    // ============================================\n    \n    address public nexusVault;\n    \n    mapping(uint256 => Position) public positions;\n    uint256 public positionIdCounter;\n    \n    mapping(uint256 => DipBuyPosition) public dipBuyPositions;\n    uint256 public dipBuyIdCounter;\n    \n    PerformanceMetrics public metrics;\n    PerformanceMetrics public dipBuyMetrics;\n    \n    // Chain-specific metrics\n    mapping(string => PerformanceMetrics) public chainMetrics;\n    \n    // Signal type performance tracking\n    mapping(uint8 => PerformanceMetrics) public signalTypeMetrics;\n    \n    // ============================================\n    // EVENTS\n    // ============================================\n    \n    event PositionOpened(\n        uint256 indexed positionId,\n        address indexed token,\n        string chain,\n        uint256 sizeUSDC,\n        uint16 confidenceScore\n    );\n    \n    event PositionClosed(\n        uint256 indexed positionId,\n        uint256 exitPrice,\n        int256 pnlUSDC,\n        PositionStatus status\n    );\n    \n    event PerformanceUpdated(\n        uint16 winRate,\n        int256 totalPnL,\n        uint256 totalPositions\n    );\n    \n    event DipBuyOpened(\n        uint256 indexed positionId,\n        address indexed token,\n        string chain,\n        uint256 sizeUSDC,\n        uint256 takeProfitPrice,\n        uint256 stopLossPrice\n    );\n    \n    event DipBuyClosed(\n        uint256 indexed positionId,\n        uint256 exitPrice,\n        int256 pnlUSDC,\n        PositionStatus status\n    );\n    \n    // ============================================\n    // MODIFIERS\n    // ============================================\n    \n    modifier onlyVault() {\n        require(msg.sender == nexusVault, \"Not authorized vault\");\n        _;\n    }\n    \n    // ============================================\n    // CONSTRUCTOR\n    // ============================================\n    \n    constructor(address _nexusVault) Ownable(msg.sender) {\n        require(_nexusVault != address(0), \"Invalid vault\");\n        nexusVault = _nexusVault;\n    }\n    \n    // ============================================\n    // CORE FUNCTIONS\n    // ============================================\n    \n    /**\n     * @notice Record a new short position\n     */\n    function recordPosition(\n        address tokenAddress,\n        string calldata chain,\n        uint256 entryPrice,\n        uint256 sizeTokens,\n        uint256 sizeUSDC,\n        uint16 confidenceScore,\n        bytes32[] calldata triggeringSignals\n    ) \n        external \n        onlyVault \n        returns (uint256 positionId) \n    {\n        positionIdCounter++;\n        positionId = positionIdCounter;\n        \n        positions[positionId] = Position({\n            id: positionId,\n            tokenAddress: tokenAddress,\n            chain: chain,\n            entryPrice: entryPrice,\n            entryTimestamp: block.timestamp,\n            sizeTokens: sizeTokens,\n            sizeUSDC: sizeUSDC,\n            exitPrice: 0,\n            exitTimestamp: 0,\n            pnlUSDC: 0,\n            confidenceScore: confidenceScore,\n            triggeringSignals: triggeringSignals,\n            status: PositionStatus.OPEN\n        });\n        \n        // Update metrics\n        metrics.totalPositions++;\n        metrics.totalVolumeUSDC += sizeUSDC;\n        \n        chainMetrics[chain].totalPositions++;\n        chainMetrics[chain].totalVolumeUSDC += sizeUSDC;\n        \n        emit PositionOpened(\n            positionId,\n            tokenAddress,\n            chain,\n            sizeUSDC,\n            confidenceScore\n        );\n        \n        return positionId;\n    }\n    \n    /**\n     * @notice Close a position and calculate P&L\n     */\n    function closePosition(\n        uint256 positionId,\n        uint256 exitPrice,\n        PositionStatus finalStatus\n    ) \n        external \n        onlyVault \n    {\n        Position storage pos = positions[positionId];\n        require(pos.status == PositionStatus.OPEN, \"Position not open\");\n        require(\n            finalStatus != PositionStatus.OPEN,\n            \"Invalid final status\"\n        );\n        \n        pos.exitPrice = exitPrice;\n        pos.exitTimestamp = block.timestamp;\n        pos.status = finalStatus;\n        \n        // Calculate P&L\n        // Short P&L = (entryPrice - exitPrice) * sizeTokens / 1e18\n        int256 priceChange = int256(pos.entryPrice) - int256(exitPrice);\n        pos.pnlUSDC = (priceChange * int256(pos.sizeTokens)) / 1e18;\n        \n        // Update global metrics\n        updatePerformanceMetrics(pos.pnlUSDC, finalStatus);\n        \n        // Update chain-specific metrics\n        updateChainMetrics(pos.chain, pos.pnlUSDC, finalStatus);\n        \n        emit PositionClosed(positionId, exitPrice, pos.pnlUSDC, finalStatus);\n        \n        emit PerformanceUpdated(\n            metrics.winRatePercent,\n            metrics.totalPnLUSDC,\n            metrics.totalPositions\n        );\n    }\n    \n    /**\n     * @notice Record a new dip buy position\n     */\n    function recordDipBuy(\n        address tokenAddress,\n        string calldata chain,\n        uint256 entryPrice,\n        uint256 sizeTokens,\n        uint256 sizeUSDC,\n        uint256 takeProfitPrice,\n        uint256 stopLossPrice,\n        uint16 confidenceScore\n    ) \n        external \n        onlyVault \n        returns (uint256 positionId) \n    {\n        dipBuyIdCounter++;\n        positionId = dipBuyIdCounter;\n        \n        dipBuyPositions[positionId] = DipBuyPosition({\n            id: positionId,\n            tokenAddress: tokenAddress,\n            chain: chain,\n            entryPrice: entryPrice,\n            entryTimestamp: block.timestamp,\n            sizeTokens: sizeTokens,\n            sizeUSDC: sizeUSDC,\n            exitPrice: 0,\n            exitTimestamp: 0,\n            pnlUSDC: 0,\n            takeProfitPrice: takeProfitPrice,\n            stopLossPrice: stopLossPrice,\n            confidenceScore: confidenceScore,\n            status: PositionStatus.OPEN\n        });\n        \n        // Update metrics\n        dipBuyMetrics.totalPositions++;\n        dipBuyMetrics.totalVolumeUSDC += sizeUSDC;\n        \n        emit DipBuyOpened(\n            positionId,\n            tokenAddress,\n            chain,\n            sizeUSDC,\n            takeProfitPrice,\n            stopLossPrice\n        );\n        \n        return positionId;\n    }\n    \n    /**\n     * @notice Close a dip buy position\n     */\n    function closeDipBuy(\n        uint256 positionId,\n        uint256 exitPrice,\n        PositionStatus finalStatus\n    ) \n        external \n        onlyVault \n    {\n        DipBuyPosition storage pos = dipBuyPositions[positionId];\n        require(pos.status == PositionStatus.OPEN, \"Position not open\");\n        require(\n            finalStatus != PositionStatus.OPEN,\n            \"Invalid final status\"\n        );\n        \n        pos.exitPrice = exitPrice;\n        pos.exitTimestamp = block.timestamp;\n        pos.status = finalStatus;\n        \n        // Calculate P&L for dip buys (profit when exitPrice > entryPrice)\n        int256 priceChange = int256(exitPrice) - int256(pos.entryPrice);\n        pos.pnlUSDC = (priceChange * int256(pos.sizeTokens)) / 1e18;\n        \n        // Update dip buy metrics\n        updateDipBuyMetrics(pos.pnlUSDC, finalStatus);\n        \n        emit DipBuyClosed(positionId, exitPrice, pos.pnlUSDC, finalStatus);\n    }\n    \n    // ============================================\n    // INTERNAL FUNCTIONS\n    // ============================================\n    \n    function updatePerformanceMetrics(\n        int256 pnl,\n        PositionStatus status\n    ) \n        internal \n    {\n        metrics.closedPositions++;\n        metrics.totalPnLUSDC += pnl;\n        \n        if (pnl > 0) {\n            metrics.profitablePositions++;\n            if (pnl > metrics.largestWin) {\n                metrics.largestWin = pnl;\n            }\n        } else if (pnl < 0) {\n            if (pnl < metrics.largestLoss) {\n                metrics.largestLoss = pnl;\n            }\n        }\n        \n        // Recalculate win rate (in basis points: 10000 = 100%)\n        if (metrics.closedPositions > 0) {\n            metrics.winRatePercent = uint16(\n                (metrics.profitablePositions * 10000) / metrics.closedPositions\n            );\n            \n            // Recalculate average P&L\n            metrics.averagePnL = metrics.totalPnLUSDC / int256(metrics.closedPositions);\n        }\n    }\n    \n    function updateChainMetrics(\n        string memory chain,\n        int256 pnl,\n        PositionStatus status\n    ) \n        internal \n    {\n        PerformanceMetrics storage chainMetric = chainMetrics[chain];\n        \n        chainMetric.closedPositions++;\n        chainMetric.totalPnLUSDC += pnl;\n        \n        if (pnl > 0) {\n            chainMetric.profitablePositions++;\n        }\n        \n        if (chainMetric.closedPositions > 0) {\n            chainMetric.winRatePercent = uint16(\n                (chainMetric.profitablePositions * 10000) / chainMetric.closedPositions\n            );\n            chainMetric.averagePnL = chainMetric.totalPnLUSDC / int256(chainMetric.closedPositions);\n        }\n    }\n    \n    function updateDipBuyMetrics(\n        int256 pnl,\n        PositionStatus status\n    ) \n        internal \n    {\n        dipBuyMetrics.closedPositions++;\n        dipBuyMetrics.totalPnLUSDC += pnl;\n        \n        if (pnl > 0) {\n            dipBuyMetrics.profitablePositions++;\n            if (pnl > dipBuyMetrics.largestWin) {\n                dipBuyMetrics.largestWin = pnl;\n            }\n        } else if (pnl < 0) {\n            if (pnl < dipBuyMetrics.largestLoss) {\n                dipBuyMetrics.largestLoss = pnl;\n            }\n        }\n        \n        // Recalculate win rate\n        if (dipBuyMetrics.closedPositions > 0) {\n            dipBuyMetrics.winRatePercent = uint16(\n                (dipBuyMetrics.profitablePositions * 10000) / dipBuyMetrics.closedPositions\n            );\n            \n            dipBuyMetrics.averagePnL = dipBuyMetrics.totalPnLUSDC / int256(dipBuyMetrics.closedPositions);\n        }\n    }\n    \n    // ============================================\n    // VIEW FUNCTIONS\n    // ============================================\n    \n    function getPosition(uint256 positionId) \n        external \n        view \n        returns (Position memory) \n    {\n        return positions[positionId];\n    }\n    \n    function getOpenPositions() \n        external \n        view \n        returns (Position[] memory) \n    {\n        uint256 openCount = 0;\n        for (uint256 i = 1; i <= positionIdCounter; i++) {\n            if (positions[i].status == PositionStatus.OPEN) {\n                openCount++;\n            }\n        }\n        \n        Position[] memory openPositions = new Position[](openCount);\n        uint256 index = 0;\n        \n        for (uint256 i = 1; i <= positionIdCounter; i++) {\n            if (positions[i].status == PositionStatus.OPEN) {\n                openPositions[index] = positions[i];\n                index++;\n            }\n        }\n        \n        return openPositions;\n    }\n    \n    function getPositionsByChain(string calldata chain) \n        external \n        view \n        returns (Position[] memory) \n    {\n        uint256 chainCount = 0;\n        for (uint256 i = 1; i <= positionIdCounter; i++) {\n            if (keccak256(bytes(positions[i].chain)) == keccak256(bytes(chain))) {\n                chainCount++;\n            }\n        }\n        \n        Position[] memory chainPositions = new Position[](chainCount);\n        uint256 index = 0;\n        \n        for (uint256 i = 1; i <= positionIdCounter; i++) {\n            if (keccak256(bytes(positions[i].chain)) == keccak256(bytes(chain))) {\n                chainPositions[index] = positions[i];\n                index++;\n            }\n        }\n        \n        return chainPositions;\n    }\n    \n    function getTopPerformers(uint256 limit) \n        external \n        view \n        returns (Position[] memory) \n    {\n        // Simple implementation - would use sorting in production\n        uint256 resultSize = limit > positionIdCounter ? positionIdCounter : limit;\n        Position[] memory topPositions = new Position[](resultSize);\n        \n        // This is a simplified version\n        // In production, implement proper sorting by pnlUSDC\n        uint256 added = 0;\n        for (uint256 i = positionIdCounter; i >= 1 && added < limit; i--) {\n            if (positions[i].status != PositionStatus.OPEN && positions[i].pnlUSDC > 0) {\n                topPositions[added] = positions[i];\n                added++;\n            }\n        }\n        \n        return topPositions;\n    }\n    \n    function getPerformanceMetrics() \n        external \n        view \n        returns (PerformanceMetrics memory) \n    {\n        return metrics;\n    }\n    \n    function getChainPerformance(string calldata chain) \n        external \n        view \n        returns (PerformanceMetrics memory) \n    {\n        return chainMetrics[chain];\n    }\n    \n    function getDipBuyPosition(uint256 positionId) \n        external \n        view \n        returns (DipBuyPosition memory) \n    {\n        return dipBuyPositions[positionId];\n    }\n    \n    function getOpenDipBuys() \n        external \n        view \n        returns (DipBuyPosition[] memory) \n    {\n        uint256 openCount = 0;\n        for (uint256 i = 1; i <= dipBuyIdCounter; i++) {\n            if (dipBuyPositions[i].status == PositionStatus.OPEN) {\n                openCount++;\n            }\n        }\n        \n        DipBuyPosition[] memory openDipBuys = new DipBuyPosition[](openCount);\n        uint256 index = 0;\n        \n        for (uint256 i = 1; i <= dipBuyIdCounter; i++) {\n            if (dipBuyPositions[i].status == PositionStatus.OPEN) {\n                openDipBuys[index] = dipBuyPositions[i];\n                index++;\n            }\n        }\n        \n        return openDipBuys;\n    }\n    \n    function getDipBuyMetrics() \n        external \n        view \n        returns (PerformanceMetrics memory) \n    {\n        return dipBuyMetrics;\n    }\n    \n    // ============================================\n    // ADMIN FUNCTIONS\n    // ============================================\n    \n    function setNexusVault(address _nexusVault) external onlyOwner {\n        require(_nexusVault != address(0), \"Invalid vault\");\n        nexusVault = _nexusVault;\n    }\n}\n"
    },
    "contracts/SignalOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title SignalOracle\n * @notice Publishes and aggregates AI agent signals on-chain\n * @dev Provides verifiable, auditable record of all signals that trigger shorts\n */\ncontract SignalOracle is Ownable {\n    // ============================================\n    // ENUMS & STRUCTS\n    // ============================================\n    \n    enum SignalType {\n        INSIDER_WALLET_DUMP,\n        LIQUIDITY_REMOVAL,\n        TWITTER_ENGAGEMENT_DROP,\n        TWITTER_SENTIMENT_NEGATIVE,\n        GOVERNANCE_BEARISH,\n        GITHUB_COMMIT_DROP,\n        DEVELOPER_EXODUS,\n        WHALE_ALERT,\n        REGULATORY_RISK,\n        MACRO_EVENT,\n        INSTITUTIONAL_MOVE,\n        SENTIMENT_SHIFT\n    }\n    \n    struct Signal {\n        SignalType signalType;\n        address tokenAddress;\n        string chain;\n        uint8 score; // 0-100\n        uint64 timestamp;\n        bytes32 metadataHash; // IPFS hash of full metadata\n        address publisher;\n    }\n    \n    // ============================================\n    // STATE VARIABLES\n    // ============================================\n    \n    address public publisherAddress; // Off-chain AI agent\n    address public nexusVault;\n    \n    // tokenKey => array of signals\n    // tokenKey = keccak256(abi.encodePacked(tokenAddress, chain))\n    mapping(bytes32 => Signal[]) public signalHistory;\n    \n    // Global signal counter for unique IDs\n    mapping(bytes32 => bytes32[]) public signalIds;\n    uint256 public globalSignalCounter;\n    \n    uint256 public constant SIGNAL_EXPIRY = 24 hours;\n    uint256 public constant SIGNAL_CLEANUP_WINDOW = 7 days;\n    \n    // ============================================\n    // EVENTS\n    // ============================================\n    \n    event SignalPublished(\n        address indexed token,\n        string chain,\n        SignalType signalType,\n        uint8 score,\n        uint64 timestamp,\n        bytes32 indexed signalId\n    );\n    \n    event SignalBatchPublished(\n        uint256 count,\n        uint64 timestamp\n    );\n    \n    event SignalsAggregated(\n        address indexed token,\n        string chain,\n        uint16 totalScore,\n        uint8 signalCount\n    );\n    \n    event PublisherUpdated(address indexed oldPublisher, address indexed newPublisher);\n    \n    // ============================================\n    // MODIFIERS\n    // ============================================\n    \n    modifier onlyPublisher() {\n        require(msg.sender == publisherAddress, \"Not authorized publisher\");\n        _;\n    }\n    \n    modifier onlyVault() {\n        require(msg.sender == nexusVault, \"Not authorized vault\");\n        _;\n    }\n    \n    // ============================================\n    // CONSTRUCTOR\n    // ============================================\n    \n    constructor(address _publisherAddress) Ownable(msg.sender) {\n        publisherAddress = _publisherAddress;\n    }\n    \n    // ============================================\n    // CORE FUNCTIONS\n    // ============================================\n    \n    /**\n     * @notice Publish a single signal\n     * @param signalType Type of signal\n     * @param tokenAddress Token being signaled\n     * @param chain Chain where token exists\n     * @param score Signal strength (0-100)\n     * @param metadataHash IPFS hash of full signal data\n     */\n    function publishSignal(\n        SignalType signalType,\n        address tokenAddress,\n        string calldata chain,\n        uint8 score,\n        bytes32 metadataHash\n    ) \n        external \n        onlyPublisher \n        returns (bytes32 signalId)\n    {\n        require(score <= 100, \"Invalid score\");\n        \n        bytes32 tokenKey = keccak256(abi.encodePacked(tokenAddress, chain));\n        \n        Signal memory newSignal = Signal({\n            signalType: signalType,\n            tokenAddress: tokenAddress,\n            chain: chain,\n            score: score,\n            timestamp: uint64(block.timestamp),\n            metadataHash: metadataHash,\n            publisher: msg.sender\n        });\n        \n        signalHistory[tokenKey].push(newSignal);\n        \n        // Generate unique signal ID\n        globalSignalCounter++;\n        signalId = keccak256(abi.encodePacked(\n            globalSignalCounter,\n            tokenAddress,\n            chain,\n            block.timestamp\n        ));\n        signalIds[tokenKey].push(signalId);\n        \n        emit SignalPublished(\n            tokenAddress,\n            chain,\n            signalType,\n            score,\n            uint64(block.timestamp),\n            signalId\n        );\n        \n        return signalId;\n    }\n    \n    /**\n     * @notice Publish multiple signals in one transaction (gas efficient)\n     * @param signals Array of signals to publish\n     */\n    function publishSignalBatch(Signal[] calldata signals) \n        external \n        onlyPublisher \n    {\n        require(signals.length > 0, \"Empty batch\");\n        require(signals.length <= 50, \"Batch too large\"); // Gas limit\n        \n        for (uint256 i = 0; i < signals.length; i++) {\n            Signal memory signal = signals[i];\n            require(signal.score <= 100, \"Invalid score\");\n            \n            bytes32 tokenKey = keccak256(abi.encodePacked(\n                signal.tokenAddress,\n                signal.chain\n            ));\n            \n            Signal memory newSignal = Signal({\n                signalType: signal.signalType,\n                tokenAddress: signal.tokenAddress,\n                chain: signal.chain,\n                score: signal.score,\n                timestamp: uint64(block.timestamp),\n                metadataHash: signal.metadataHash,\n                publisher: msg.sender\n            });\n            \n            signalHistory[tokenKey].push(newSignal);\n            \n            // Generate signal ID\n            globalSignalCounter++;\n            bytes32 signalId = keccak256(abi.encodePacked(\n                globalSignalCounter,\n                signal.tokenAddress,\n                signal.chain,\n                block.timestamp\n            ));\n            signalIds[tokenKey].push(signalId);\n            \n            emit SignalPublished(\n                signal.tokenAddress,\n                signal.chain,\n                signal.signalType,\n                signal.score,\n                uint64(block.timestamp),\n                signalId\n            );\n        }\n        \n        emit SignalBatchPublished(signals.length, uint64(block.timestamp));\n    }\n    \n    // ============================================\n    // VIEW FUNCTIONS\n    // ============================================\n    \n    /**\n     * @notice Get aggregated confidence score for a token\n     * @param tokenAddress Token to check\n     * @param chain Chain where token exists\n     * @return totalScore Sum of all recent signal scores\n     * @return signalCount Number of recent signals\n     */\n    function getConfidenceScore(\n        address tokenAddress,\n        string calldata chain\n    ) \n        external \n        view \n        returns (uint16 totalScore, uint8 signalCount) \n    {\n        bytes32 tokenKey = keccak256(abi.encodePacked(tokenAddress, chain));\n        Signal[] memory signals = signalHistory[tokenKey];\n        \n        uint64 cutoffTime = uint64(block.timestamp) - uint64(SIGNAL_EXPIRY);\n        \n        for (uint256 i = 0; i < signals.length; i++) {\n            if (signals[i].timestamp > cutoffTime) {\n                totalScore += signals[i].score;\n                signalCount++;\n            }\n        }\n        \n        return (totalScore, signalCount);\n    }\n    \n    /**\n     * @notice Get recent signal IDs for position recording\n     */\n    function getRecentSignalIds(\n        address tokenAddress,\n        string calldata chain\n    ) \n        external \n        view \n        returns (bytes32[] memory) \n    {\n        bytes32 tokenKey = keccak256(abi.encodePacked(tokenAddress, chain));\n        bytes32[] memory allIds = signalIds[tokenKey];\n        \n        // Count recent signals\n        Signal[] memory signals = signalHistory[tokenKey];\n        uint64 cutoffTime = uint64(block.timestamp) - uint64(SIGNAL_EXPIRY);\n        \n        uint256 recentCount = 0;\n        for (uint256 i = 0; i < signals.length; i++) {\n            if (signals[i].timestamp > cutoffTime) {\n                recentCount++;\n            }\n        }\n        \n        // Return only recent IDs\n        bytes32[] memory recentIds = new bytes32[](recentCount);\n        uint256 index = 0;\n        \n        for (uint256 i = 0; i < signals.length; i++) {\n            if (signals[i].timestamp > cutoffTime && index < recentCount) {\n                recentIds[index] = allIds[i];\n                index++;\n            }\n        }\n        \n        return recentIds;\n    }\n    \n    /**\n     * @notice Get all signals for a token\n     */\n    function getSignalHistory(\n        address tokenAddress,\n        string calldata chain\n    ) \n        external \n        view \n        returns (Signal[] memory) \n    {\n        bytes32 tokenKey = keccak256(abi.encodePacked(tokenAddress, chain));\n        return signalHistory[tokenKey];\n    }\n    \n    /**\n     * @notice Get signals by type\n     */\n    function getSignalsByType(\n        address tokenAddress,\n        string calldata chain,\n        SignalType signalType\n    ) \n        external \n        view \n        returns (Signal[] memory) \n    {\n        bytes32 tokenKey = keccak256(abi.encodePacked(tokenAddress, chain));\n        Signal[] memory allSignals = signalHistory[tokenKey];\n        \n        // Count matching signals\n        uint256 matchCount = 0;\n        for (uint256 i = 0; i < allSignals.length; i++) {\n            if (allSignals[i].signalType == signalType) {\n                matchCount++;\n            }\n        }\n        \n        // Populate result\n        Signal[] memory result = new Signal[](matchCount);\n        uint256 index = 0;\n        for (uint256 i = 0; i < allSignals.length; i++) {\n            if (allSignals[i].signalType == signalType) {\n                result[index] = allSignals[i];\n                index++;\n            }\n        }\n        \n        return result;\n    }\n    \n    // ============================================\n    // ADMIN FUNCTIONS\n    // ============================================\n    \n    function setPublisher(address newPublisher) external onlyOwner {\n        require(newPublisher != address(0), \"Invalid publisher\");\n        address oldPublisher = publisherAddress;\n        publisherAddress = newPublisher;\n        emit PublisherUpdated(oldPublisher, newPublisher);\n    }\n    \n    function setNexusVault(address _nexusVault) external onlyOwner {\n        require(_nexusVault != address(0), \"Invalid vault\");\n        nexusVault = _nexusVault;\n    }\n    \n    /**\n     * @notice Clean up expired signals to save gas on reads\n     */\n    function cleanExpiredSignals(\n        address tokenAddress,\n        string calldata chain\n    ) \n        external \n    {\n        bytes32 tokenKey = keccak256(abi.encodePacked(tokenAddress, chain));\n        Signal[] storage signals = signalHistory[tokenKey];\n        \n        uint64 cleanupCutoff = uint64(block.timestamp) - uint64(SIGNAL_CLEANUP_WINDOW);\n        \n        // Remove signals older than cleanup window\n        uint256 i = 0;\n        while (i < signals.length) {\n            if (signals[i].timestamp < cleanupCutoff) {\n                // Swap with last element and pop\n                signals[i] = signals[signals.length - 1];\n                signals.pop();\n            } else {\n                i++;\n            }\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}